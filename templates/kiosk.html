<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiosk Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none; /* Hide mouse cursor */
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none; /* Hide mouse cursor */
        }

        #slideshow-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slide {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-in-out;
        }

        .slide.no-transition {
            transition: none;
        }

        .slide.active {
            opacity: 1;
            pointer-events: auto;
        }

        .slide img {
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            object-position: center;
            /* Default: cover mode fills the screen, may crop edges slightly */
            /* This maximizes screen usage for your 2560x2880 portrait display */
        }

        /* Cropped images use custom positioning */
        .slide img.cropped {
            /* Don't set width/height here - let JavaScript inline styles control size */
            object-fit: none !important;
            max-width: none !important;
            max-height: none !important;
        }

        /* Alternative: contain mode shows full image with possible black bars */
        .slide.contain-mode img {
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        #loading {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="slideshow-container">
        <div id="loading">Loading images...</div>
    </div>

    <script>
        let images = [];
        let currentIndex = 0;
        let interval = {{ interval }} * 1000; // Convert to milliseconds (I)
        let checkInterval = {{ check_interval }} * 1000; // Convert to milliseconds (C)
        let slideTimer = null;
        let fillMode = false; // false = cover mode (fills screen), true = contain mode (shows full image)
        let previousImageVector = []; // VP - previous vector of enabled image names

        // Debug logging function - sends to both console and server
        async function debugLog(message, level = 'info') {
            console.log(message);

            try {
                await fetch('/api/debug/log', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ message, level })
                });
            } catch (error) {
                // Silently fail if debug logging fails
            }
        }

        // Get vector of image names from image objects
        function getImageVector(imageList) {
            return imageList.map(img => img.name).sort();
        }

        // Compare two vectors to see if they're different
        function vectorsAreDifferent(v1, v2) {
            if (v1.length !== v2.length) return true;
            for (let i = 0; i < v1.length; i++) {
                if (v1[i] !== v2[i]) return true;
            }
            return false;
        }

        // Store crop settings globally
        let imageCrops = {};

        // Fetch images from API
        async function loadImages(startIndex = 0) {
            try {
                // Only fetch enabled images for the kiosk display
                const response = await fetch('/api/images?enabled_only=true');
                const newImages = await response.json();

                if (newImages.length === 0) {
                    document.getElementById('loading').textContent = 'No images enabled. Visit /manage to enable images.';
                    return;
                }

                images = newImages;
                previousImageVector = getImageVector(images); // Store current vector as VP

                // Load crop settings
                const settingsResponse = await fetch('/api/settings');
                const settings = await settingsResponse.json();
                imageCrops = settings.image_crops || {};
                debugLog(`Loaded ${Object.keys(imageCrops).length} image crops from settings`, 'info');
                if (Object.keys(imageCrops).length > 0) {
                    debugLog(`Crops for: ${Object.keys(imageCrops).join(', ')}`, 'info');
                }

                // Hide loading message
                document.getElementById('loading').style.display = 'none';

                // Create slides with specified start index
                initSlideshow(startIndex);
            } catch (error) {
                console.error('Error loading images:', error);
                document.getElementById('loading').textContent = 'Error loading images. Please refresh.';
            }
        }

        // Check if enabled images or settings have changed
        async function checkForImageChanges() {
            try {
                // Check for image changes
                const imagesResponse = await fetch('/api/images?enabled_only=true');
                const newImages = await imagesResponse.json();
                const newVector = getImageVector(newImages); // V - new vector

                // Check for settings changes
                const settingsResponse = await fetch('/api/settings');
                const settings = await settingsResponse.json();
                const newInterval = settings.interval * 1000;
                const newImageCrops = settings.image_crops || {};

                let needsReload = false;

                // Check if images changed
                if (vectorsAreDifferent(newVector, previousImageVector)) {
                    await debugLog(`Enabled images changed!`, 'info');
                    await debugLog(`Old vector (VP): [${previousImageVector.join(', ')}]`);
                    await debugLog(`New vector (V): [${newVector.join(', ')}]`);
                    needsReload = true;
                }

                // Check if interval changed
                if (newInterval !== interval) {
                    await debugLog(`Interval changed! ${interval / 1000}s -> ${newInterval / 1000}s`);
                    interval = newInterval;
                    needsReload = true;
                }

                // Check if crops changed
                if (JSON.stringify(newImageCrops) !== JSON.stringify(imageCrops)) {
                    await debugLog(`Image crops changed!`, 'info');
                    imageCrops = newImageCrops;
                    needsReload = true;
                }

                if (needsReload) {
                    await debugLog('Reloading slideshow...', 'info');
                    await reloadSlideshow();
                }
            } catch (error) {
                console.error('Error checking for changes:', error);
                await debugLog(`Error checking for changes: ${error.message}`, 'error');
            }
        }

        // Reload slideshow with new images
        async function reloadSlideshow() {
            // Save current image name to restore position after reload
            const currentImageName = images[currentIndex]?.name;

            // Stop current slideshow
            if (slideTimer) {
                clearInterval(slideTimer);
            }

            // Clear existing slides
            const container = document.getElementById('slideshow-container');
            const slides = container.querySelectorAll('.slide');
            slides.forEach(slide => slide.remove());

            // Temporarily store old images list to find the index
            const oldImages = images;
            const oldIndex = currentIndex;

            // Reload images first to get new image list
            const response = await fetch('/api/images?enabled_only=true');
            const newImages = await response.json();

            // Find where the current image is in the new list
            let startIndex = 0;
            if (currentImageName && newImages.length > 0) {
                const foundIndex = newImages.findIndex(img => img.name === currentImageName);
                if (foundIndex !== -1) {
                    startIndex = foundIndex;
                }
            }

            // Now reload with the correct start index
            await loadImages(startIndex);
        }

        // Initialize slideshow
        function initSlideshow(startIndex = 0) {
            const container = document.getElementById('slideshow-container');

            // Create slide elements
            images.forEach((image, index) => {
                const slide = document.createElement('div');
                slide.className = 'slide';
                slide.dataset.index = index;

                // Check if crop exists for this image
                const cropData = imageCrops[image.name];

                if (cropData) {
                    debugLog(`Creating cropped slide for ${image.name}`, 'info');
                    // Create cropped image using a container
                    const cropContainer = document.createElement('div');
                    cropContainer.style.width = '100%';
                    cropContainer.style.height = '100%';
                    cropContainer.style.overflow = 'hidden';
                    cropContainer.style.position = 'absolute';
                    cropContainer.style.top = '0';
                    cropContainer.style.left = '0';

                    const img = document.createElement('img');
                    img.src = image.url;
                    img.alt = image.name;
                    img.dataset.imageName = image.name;
                    img.className = 'cropped'; // Mark as cropped for CSS

                    cropContainer.appendChild(img);
                    slide.appendChild(cropContainer);

                    // Apply crop styling when image loads
                    applyCrop(img, cropContainer, cropData);
                } else {
                    // No crop - use normal full image
                    const img = document.createElement('img');
                    img.src = image.url;
                    img.alt = image.name;
                    slide.appendChild(img);
                }

                container.appendChild(slide);
            });

            // Show specified image
            showSlide(startIndex);

            // Start automatic slideshow
            startSlideshow();
        }

        // Apply crop to an image element
        function applyCrop(img, container, cropData) {
            debugLog(`applyCrop called for ${img.alt}`, 'info');

            const applyStyles = () => {
                debugLog(`applyStyles running for ${img.alt}`, 'info');

                // Get viewport dimensions (use container dimensions since it should be 100vw x 100vh)
                const viewportW = container.clientWidth;
                const viewportH = container.clientHeight;

                // Check if container has valid dimensions
                if (viewportW === 0 || viewportH === 0) {
                    debugLog(`ERROR: Container has zero dimensions (${viewportW}x${viewportH}) - cannot apply crop`, 'error');
                    return;
                }

                const viewportAspect = viewportW / viewportH;

                // Get crop dimensions from saved data
                const cropX = cropData.x;
                const cropY = cropData.y;
                const cropW = cropData.width;
                const cropH = cropData.height;
                const cropAspect = cropW / cropH;
                const imgW = cropData.imageWidth;
                const imgH = cropData.imageHeight;

                // Calculate scale to make crop region fill viewport completely (cover behavior)
                // Use Math.max to ensure the crop region fills the entire viewport
                const scaleX = viewportW / cropW;
                const scaleY = viewportH / cropH;
                const scale = Math.max(scaleX, scaleY);

                // Calculate scaled image dimensions
                const scaledImgW = imgW * scale;
                const scaledImgH = imgH * scale;

                // Calculate scaled crop dimensions
                const scaledCropW = cropW * scale;
                const scaledCropH = cropH * scale;

                // Calculate position to place crop region
                // Move image so crop region starts at correct position
                const offsetX = -cropX * scale;
                const offsetY = -cropY * scale;

                // Center the crop region in viewport
                // If crop is larger than viewport in one dimension, center the overflow
                const centerX = (viewportW - scaledCropW) / 2;
                const centerY = (viewportH - scaledCropH) / 2;

                // Apply styles with !important to override any CSS
                img.style.setProperty('position', 'absolute', 'important');
                img.style.setProperty('width', `${scaledImgW}px`, 'important');
                img.style.setProperty('height', `${scaledImgH}px`, 'important');
                img.style.setProperty('left', `${offsetX + centerX}px`, 'important');
                img.style.setProperty('top', `${offsetY + centerY}px`, 'important');
                img.style.setProperty('object-fit', 'none', 'important');
                img.style.setProperty('max-width', 'none', 'important');
                img.style.setProperty('max-height', 'none', 'important');
                img.style.setProperty('margin', '0', 'important');
                img.style.setProperty('padding', '0', 'important');

                // Debug log - send to management interface
                debugLog(`Crop applied to ${img.alt}:`, 'info');
                debugLog(`  Container: ${container.clientWidth}x${container.clientHeight}`, 'info');
                debugLog(`  Viewport: ${viewportW}x${viewportH} (aspect ${viewportAspect.toFixed(2)})`, 'info');
                debugLog(`  Original Image: ${imgW}x${imgH}`, 'info');
                debugLog(`  Crop Region: ${cropW.toFixed(0)}x${cropH.toFixed(0)} (aspect ${cropAspect.toFixed(2)})`, 'info');
                debugLog(`  Crop Position in Original: x=${cropX.toFixed(0)}, y=${cropY.toFixed(0)}`, 'info');
                debugLog(`  Scale X: ${scaleX.toFixed(2)}, Scale Y: ${scaleY.toFixed(2)} -> Using: ${scale.toFixed(2)}`, 'info');
                debugLog(`  Scaled Image: ${scaledImgW.toFixed(0)}x${scaledImgH.toFixed(0)}`, 'info');
                debugLog(`  Scaled Crop: ${scaledCropW.toFixed(0)}x${scaledCropH.toFixed(0)}`, 'info');
                debugLog(`  Offset (from crop position): x=${offsetX.toFixed(0)}, y=${offsetY.toFixed(0)}`, 'info');
                debugLog(`  Center adjustment: x=${centerX.toFixed(0)}, y=${centerY.toFixed(0)}`, 'info');
                debugLog(`  Final Position: left=${(offsetX + centerX).toFixed(0)}px, top=${(offsetY + centerY).toFixed(0)}px`, 'info');

                // Verify what was actually applied
                debugLog(`  Applied CSS: width=${img.style.width}, height=${img.style.height}, left=${img.style.left}, top=${img.style.top}`, 'info');

                // Check if crop overflows or has black bars
                if (scaledCropW > viewportW) {
                    debugLog(`  Width overflow: ${(scaledCropW - viewportW).toFixed(0)}px (${((scaledCropW - viewportW) / 2).toFixed(0)}px on each side)`, 'info');
                } else if (scaledCropW < viewportW) {
                    debugLog(`  Width black bars: ${(viewportW - scaledCropW).toFixed(0)}px total (${((viewportW - scaledCropW) / 2).toFixed(0)}px on each side)`, 'info');
                }

                if (scaledCropH > viewportH) {
                    debugLog(`  Height overflow: ${(scaledCropH - viewportH).toFixed(0)}px (${((scaledCropH - viewportH) / 2).toFixed(0)}px on top/bottom)`, 'info');
                } else if (scaledCropH < viewportH) {
                    debugLog(`  Height black bars: ${(viewportH - scaledCropH).toFixed(0)}px total (${((viewportH - scaledCropH) / 2).toFixed(0)}px on top/bottom)`, 'info');
                }
            };

            // Apply immediately if already loaded, otherwise wait
            if (img.complete && img.naturalWidth > 0) {
                debugLog(`Image ${img.alt} already loaded, applying styles immediately`, 'info');
                applyStyles();
            } else {
                debugLog(`Image ${img.alt} not loaded yet, waiting for onload`, 'info');
                img.onload = applyStyles;
            }
        }

        // Show specific slide
        function showSlide(index) {
            const slides = document.querySelectorAll('.slide');

            // Hide all slides
            slides.forEach(slide => {
                slide.classList.remove('active');
            });

            // Show current slide
            if (slides[index]) {
                slides[index].classList.add('active');
                currentIndex = index;

                // Check if this slide has a cropped image and reapply crop
                const cropContainer = slides[index].querySelector('div[style*="overflow: hidden"]');
                if (cropContainer) {
                    const img = cropContainer.querySelector('img');
                    const imageName = img.alt;
                    const cropData = imageCrops[imageName];

                    if (cropData) {
                        debugLog(`Reapplying crop for ${imageName} when showing slide`, 'info');
                        // Reapply the crop now that the slide is active and has dimensions
                        applyCrop(img, cropContainer, cropData);
                    }
                }
            }
        }

        // Next slide
        function nextSlide() {
            currentIndex = (currentIndex + 1) % images.length;
            showSlide(currentIndex);
        }

        // Previous slide
        function prevSlide() {
            currentIndex = (currentIndex - 1 + images.length) % images.length;
            showSlide(currentIndex);
        }

        // Start automatic slideshow
        function startSlideshow() {
            if (slideTimer) {
                clearInterval(slideTimer);
            }

            slideTimer = setInterval(nextSlide, interval);
        }

        // Toggle between cover (default, fills screen) and contain (shows full image)
        function toggleFillMode() {
            fillMode = !fillMode;
            const slides = document.querySelectorAll('.slide');
            slides.forEach(slide => {
                if (fillMode) {
                    slide.classList.add('contain-mode');
                } else {
                    slide.classList.remove('contain-mode');
                }
            });
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    nextSlide();
                    // Only restart timer if not paused
                    if (!isPaused) {
                        startSlideshow();
                    }
                    break;
                case 'ArrowLeft':
                    prevSlide();
                    // Only restart timer if not paused
                    if (!isPaused) {
                        startSlideshow();
                    }
                    break;
                case 'f':
                case 'F':
                    toggleFillMode();
                    break;
                case 'r':
                case 'R':
                    location.reload();
                    break;
            }
        });

        // Poll for remote control commands
        let isPaused = false;

        async function pollRemoteControl() {
            try {
                const response = await fetch('/api/control/poll');
                const data = await response.json();

                if (data.command) {
                    executeCommand(data.command);
                }
            } catch (error) {
                console.error('Error polling for commands:', error);
            }
        }

        // Execute remote command
        async function executeCommand(command) {
            // Handle jump command (object with command and image_name)
            if (typeof command === 'object' && command.command === 'jump') {
                const imageName = command.image_name;
                const imageIndex = images.findIndex(img => img.name === imageName);
                if (imageIndex !== -1) {
                    showSlide(imageIndex);
                    // Restart slideshow if not paused
                    if (!isPaused) {
                        startSlideshow();
                    }
                }
                return;
            }

            // Handle string commands
            switch(command) {
                case 'next':
                    nextSlide();
                    // Only restart slideshow if not paused
                    if (!isPaused) {
                        startSlideshow();
                    }
                    break;
                case 'prev':
                    prevSlide();
                    // Only restart slideshow if not paused
                    if (!isPaused) {
                        startSlideshow();
                    }
                    break;
                case 'pause':
                    if (slideTimer) {
                        clearInterval(slideTimer);
                        slideTimer = null;
                        isPaused = true;
                    }
                    break;
                case 'play':
                    isPaused = false;
                    startSlideshow();
                    break;
                case 'reload':
                    isPaused = false; // Resume playback on reload
                    await reloadSlideshow();
                    break;
            }
        }

        // Send initial debug message
        debugLog('Kiosk display starting... (I=' + (interval/1000) + 's, C=' + (checkInterval/1000) + 's)', 'info');

        // Poll for commands every 500ms
        setInterval(pollRemoteControl, 500);

        // Check for enabled image changes every C seconds
        setInterval(checkForImageChanges, checkInterval);

        // Load images on page load
        loadImages();
    </script>
</body>
</html>
