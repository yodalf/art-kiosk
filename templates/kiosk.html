<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiosk Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none; /* Hide mouse cursor */
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none; /* Hide mouse cursor */
        }

        #slideshow-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slide {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-in-out;
        }

        /* Cropped slides don't need flexbox centering */
        .slide.has-crop {
            display: block;
        }

        .slide.no-transition {
            transition: none;
        }

        .slide.active {
            opacity: 1 !important;
            pointer-events: auto;
        }

        .slide img:not(.cropped) {
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            object-position: center;
            /* Default: cover mode fills the screen, may crop edges slightly */
            /* This maximizes screen usage for your 2560x2880 portrait display */
        }

        /* Cropped images use custom positioning - JavaScript controls everything */
        .slide img.cropped {
            /* JavaScript will set width/height/position via inline styles */
            /* object-fit will be set by JavaScript to 'fill' to allow scaling */
            object-position: initial;
            max-width: none !important;
            max-height: none !important;
        }

        /* Alternative: contain mode shows full image with possible black bars */
        .slide.contain-mode img {
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        #loading {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="slideshow-container">
        <div id="loading">Loading images...</div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // Initialize Socket.IO connection
        const socket = io();

        let images = [];
        let currentIndex = 0;
        let interval = {{ interval }} * 1000; // Convert to milliseconds (I)
        let checkInterval = {{ check_interval }} * 1000; // Convert to milliseconds (C)
        let slideTimer = null;
        let fillMode = false; // false = cover mode (fills screen), true = contain mode (shows full image)
        let previousImageVector = []; // VP - previous vector of enabled image names
        let previousShuffleId = null; // Track shuffle_id to detect order changes

        // Debug logging function - sends to both console and server
        function debugLog(message, level = 'info') {
            console.log(message);

            // Send to server via WebSocket
            if (socket.connected) {
                socket.emit('log_debug', { message, level });
            }
        }

        // Get vector of image names from image objects
        function getImageVector(imageList) {
            return imageList.map(img => img.name).sort();
        }

        // Compare two vectors to see if they're different
        function vectorsAreDifferent(v1, v2) {
            if (v1.length !== v2.length) return true;
            for (let i = 0; i < v1.length; i++) {
                if (v1[i] !== v2[i]) return true;
            }
            return false;
        }

        // Store crop settings globally
        let imageCrops = {};

        // Fetch images from API
        async function loadImages(startIndex = 0, startImageName = null) {
            try {
                // Stop current slideshow
                if (slideTimer) {
                    clearInterval(slideTimer);
                }

                // Clear existing slides to prevent duplicates
                const container = document.getElementById('slideshow-container');
                const slides = container.querySelectorAll('.slide');
                slides.forEach(slide => slide.remove());

                // Only fetch enabled images for the kiosk display
                const response = await fetch('/api/images?enabled_only=true');
                const newImages = await response.json();

                if (newImages.length === 0) {
                    document.getElementById('loading').textContent = 'No images enabled. Visit /manage to enable images.';
                    return;
                }

                // If a starting image name was provided, find its index
                if (startImageName && newImages.length > 0) {
                    const foundIndex = newImages.findIndex(img => img.name === startImageName);
                    if (foundIndex !== -1) {
                        startIndex = foundIndex;
                        debugLog(`Starting from requested image: ${startImageName} at index ${startIndex}`, 'info');
                    }
                }

                images = newImages;
                previousImageVector = getImageVector(images); // Store current vector as VP

                // Load crop settings and shuffle_id
                const settingsResponse = await fetch('/api/settings');
                const settings = await settingsResponse.json();
                imageCrops = settings.image_crops || {};
                previousShuffleId = settings.shuffle_id; // Store shuffle_id to detect order changes
                debugLog(`Loaded ${Object.keys(imageCrops).length} image crops from settings`, 'info');
                if (Object.keys(imageCrops).length > 0) {
                    debugLog(`Crops for: ${Object.keys(imageCrops).join(', ')}`, 'info');
                }

                // Hide loading message
                document.getElementById('loading').style.display = 'none';

                // Create slides with specified start index
                initSlideshow(startIndex);
            } catch (error) {
                console.error('Error loading images:', error);
                document.getElementById('loading').textContent = 'Error loading images. Please refresh.';
            }
        }

        // Check if enabled images or settings have changed
        async function checkForImageChanges() {
            try {
                // Check for image changes
                const imagesResponse = await fetch('/api/images?enabled_only=true');
                const newImages = await imagesResponse.json();
                const newVector = getImageVector(newImages); // V - new vector

                // Check for settings changes
                const settingsResponse = await fetch('/api/settings');
                const settings = await settingsResponse.json();
                const newInterval = settings.interval * 1000;
                const newImageCrops = settings.image_crops || {};
                const newShuffleId = settings.shuffle_id;

                let needsReload = false;

                // Check if images changed
                if (vectorsAreDifferent(newVector, previousImageVector)) {
                    debugLog(`Enabled images changed!`, 'info');
                    debugLog(`Old vector (VP): [${previousImageVector.join(', ')}]`);
                    debugLog(`New vector (V): [${newVector.join(', ')}]`);
                    needsReload = true;
                }

                // Check if shuffle_id changed (theme/atmosphere switched)
                let shuffleChanged = false;
                if (newShuffleId !== previousShuffleId) {
                    debugLog(`Shuffle ID changed! Order will be refreshed.`, 'info');
                    previousShuffleId = newShuffleId;
                    shuffleChanged = true;
                    needsReload = true;
                }

                // Check if interval changed
                if (newInterval !== interval) {
                    debugLog(`Interval changed! ${interval / 1000}s -> ${newInterval / 1000}s`);
                    interval = newInterval;
                    needsReload = true;
                }

                // Check if crops changed
                let cropsChanged = false;
                if (JSON.stringify(newImageCrops) !== JSON.stringify(imageCrops)) {
                    debugLog(`Image crops changed!`, 'info');
                    cropsChanged = true;
                    imageCrops = newImageCrops;
                    needsReload = true;
                }

                // Don't reload if currently viewing an extra image overlay
                const extraOverlay = document.querySelector('.extra-image-overlay');
                if (extraOverlay) {
                    debugLog('Extra image overlay active, skipping slideshow reload', 'info');
                    // But if crops changed, we need to refresh the extra image overlay
                    if (cropsChanged) {
                        // Extract the image name from the overlay
                        const bgImage = extraOverlay.style.backgroundImage || '';
                        const match = bgImage.match(/\/extra-images\/([^')]+)/);
                        if (match) {
                            const extraImageName = decodeURIComponent(match[1]);
                            debugLog(`Refreshing extra image overlay with updated crop: ${extraImageName}`, 'info');
                            // Re-execute jump_extra to recreate the overlay with the new crop
                            await executeCommand({ command: 'jump_extra', image_name: extraImageName });
                        }
                    }
                    // Update imageCrops but don't reload slideshow
                    needsReload = false;
                }

                if (needsReload) {
                    debugLog('Reloading slideshow...', 'info');
                    await reloadSlideshow(shuffleChanged);
                }
            } catch (error) {
                console.error('Error checking for changes:', error);
                debugLog(`Error checking for changes: ${error.message}`, 'error');
            }
        }

        // Reload slideshow with new images
        async function reloadSlideshow(shuffleChanged = false) {
            // Check if an extra image overlay is currently displayed
            const container = document.getElementById('slideshow-container');
            const extraOverlay = container.querySelector('.extra-image-overlay');
            let extraImageName = null;

            if (extraOverlay) {
                // Extract the image name from the background-image URL
                const bgImage = extraOverlay.style.backgroundImage;
                const match = bgImage.match(/\/extra-images\/([^')]+)/);
                if (match) {
                    extraImageName = decodeURIComponent(match[1]);
                    debugLog(`Extra image overlay detected: ${extraImageName}, will restore after reload`, 'info');
                }
            }

            // Save current image name to restore position after reload
            const currentImageName = images[currentIndex]?.name;

            // Stop current slideshow
            if (slideTimer) {
                clearInterval(slideTimer);
            }

            // Clear existing slides
            const slides = container.querySelectorAll('.slide');
            slides.forEach(slide => slide.remove());

            // Temporarily store old images list to find the index
            const oldImages = images;
            const oldIndex = currentIndex;

            // Reload images first to get new image list
            const response = await fetch('/api/images?enabled_only=true');
            const newImages = await response.json();

            // Find where the current image is in the new list
            let startIndex = 0;
            // Only preserve position if shuffle didn't change
            if (!shuffleChanged && currentImageName && newImages.length > 0) {
                const foundIndex = newImages.findIndex(img => img.name === currentImageName);
                if (foundIndex !== -1) {
                    startIndex = foundIndex;
                }
            }

            // Now reload with the correct start index
            await loadImages(startIndex);

            // If an extra image was being displayed, restore it
            if (extraImageName) {
                debugLog(`Restoring extra image overlay: ${extraImageName}`, 'info');
                // Re-execute the jump_extra command to restore the overlay
                await executeCommand({ command: 'jump_extra', image_name: extraImageName });
            }
        }

        // Initialize slideshow
        function initSlideshow(startIndex = 0) {
            const container = document.getElementById('slideshow-container');

            // Create slide elements
            images.forEach((image, index) => {
                const slide = document.createElement('div');
                slide.className = 'slide';
                if (fillMode) {
                    slide.classList.add('contain-mode');
                }
                slide.dataset.index = index;

                // Check if crop exists for this image
                const cropData = imageCrops[image.name];

                if (cropData) {
                    debugLog(`Creating cropped slide for ${image.name}`, 'info');
                    // Mark slide as having a crop
                    slide.classList.add('has-crop');
                    // Create cropped image using a container
                    const cropContainer = document.createElement('div');
                    cropContainer.style.width = '100%';
                    cropContainer.style.height = '100%';
                    cropContainer.style.overflow = 'hidden';
                    cropContainer.style.position = 'absolute';
                    cropContainer.style.top = '0';
                    cropContainer.style.left = '0';

                    const img = document.createElement('img');
                    img.src = image.url;
                    img.alt = image.name;
                    img.dataset.imageName = image.name;
                    img.className = 'cropped'; // Mark as cropped for CSS

                    cropContainer.appendChild(img);
                    slide.appendChild(cropContainer);

                    // Apply crop styling when image loads
                    applyCrop(img, cropContainer, cropData);
                } else {
                    // No crop - use normal full image
                    const img = document.createElement('img');
                    img.src = image.url;
                    img.alt = image.name;
                    slide.appendChild(img);
                }

                container.appendChild(slide);
            });

            // Show specified image
            showSlide(startIndex);

            // Start automatic slideshow
            startSlideshow();
        }

        // Apply crop to an image element
        function applyCrop(img, container, cropData) {
            debugLog(`applyCrop called for ${img.alt}`, 'info');
            debugLog(`Raw crop data: x=${cropData.x}, y=${cropData.y}, w=${cropData.width}, h=${cropData.height}, imgW=${cropData.imageWidth}, imgH=${cropData.imageHeight}`, 'info');

            const applyStyles = () => {
                debugLog(`applyStyles running for ${img.alt}`, 'info');

                // Get viewport dimensions (use container dimensions since it should be 100vw x 100vh)
                const viewportW = container.clientWidth;
                const viewportH = container.clientHeight;

                // Check if container has valid dimensions
                if (viewportW === 0 || viewportH === 0) {
                    debugLog(`ERROR: Container has zero dimensions (${viewportW}x${viewportH}) - cannot apply crop`, 'error');
                    return;
                }

                const viewportAspect = viewportW / viewportH;

                // Get crop dimensions from saved data
                const cropX = cropData.x;
                const cropY = cropData.y;
                const cropW = cropData.width;
                const cropH = cropData.height;
                const cropAspect = cropW / cropH;
                const imgW = cropData.imageWidth;
                const imgH = cropData.imageHeight;

                // Calculate scale to make crop region fill viewport completely (cover behavior)
                // Use Math.max to ensure the crop region fills the entire viewport
                const scaleX = viewportW / cropW;
                const scaleY = viewportH / cropH;
                const scale = Math.max(scaleX, scaleY);

                // Calculate scaled image dimensions
                const scaledImgW = imgW * scale;
                const scaledImgH = imgH * scale;

                // Calculate scaled crop dimensions
                const scaledCropW = cropW * scale;
                const scaledCropH = cropH * scale;

                // Calculate position to place crop region
                // Move image so crop region starts at correct position
                const offsetX = -cropX * scale;
                const offsetY = -cropY * scale;

                // Center the crop region in viewport
                // If crop is larger than viewport in one dimension, center the overflow
                const centerX = (viewportW - scaledCropW) / 2;
                const centerY = (viewportH - scaledCropH) / 2;

                // Apply styles with !important to override any CSS
                // First, explicitly remove any problematic CSS properties
                img.style.removeProperty('width');
                img.style.removeProperty('height');

                // Now set our exact values
                img.style.setProperty('position', 'absolute', 'important');
                img.style.setProperty('width', `${scaledImgW}px`, 'important');
                img.style.setProperty('height', `${scaledImgH}px`, 'important');
                img.style.setProperty('min-width', `${scaledImgW}px`, 'important');
                img.style.setProperty('min-height', `${scaledImgH}px`, 'important');
                img.style.setProperty('left', `${offsetX + centerX}px`, 'important');
                img.style.setProperty('top', `${offsetY + centerY}px`, 'important');
                // DO NOT set object-fit to 'none' - it prevents scaling!
                // We want the image to scale to our width/height, so use default or 'fill'
                img.style.setProperty('object-fit', 'fill', 'important');
                img.style.setProperty('max-width', 'none', 'important');
                img.style.setProperty('max-height', 'none', 'important');
                img.style.setProperty('margin', '0', 'important');
                img.style.setProperty('padding', '0', 'important');
                img.style.setProperty('transform', 'none', 'important');
                img.style.setProperty('display', 'block', 'important');

                // Debug log - send to management interface
                debugLog(`Crop applied to ${img.alt}:`, 'info');
                debugLog(`  Container: ${container.clientWidth}x${container.clientHeight}`, 'info');
                debugLog(`  Viewport: ${viewportW}x${viewportH} (aspect ${viewportAspect.toFixed(2)})`, 'info');
                debugLog(`  Original Image: ${imgW}x${imgH}`, 'info');
                debugLog(`  Crop Region: ${cropW.toFixed(0)}x${cropH.toFixed(0)} (aspect ${cropAspect.toFixed(2)})`, 'info');
                debugLog(`  Crop Position in Original: x=${cropX.toFixed(0)}, y=${cropY.toFixed(0)}`, 'info');
                debugLog(`  Scale X: ${scaleX.toFixed(2)}, Scale Y: ${scaleY.toFixed(2)} -> Using: ${scale.toFixed(2)}`, 'info');
                debugLog(`  Scaled Image: ${scaledImgW.toFixed(0)}x${scaledImgH.toFixed(0)}`, 'info');
                debugLog(`  Scaled Crop: ${scaledCropW.toFixed(0)}x${scaledCropH.toFixed(0)}`, 'info');
                debugLog(`  Offset (from crop position): x=${offsetX.toFixed(0)}, y=${offsetY.toFixed(0)}`, 'info');
                debugLog(`  Center adjustment: x=${centerX.toFixed(0)}, y=${centerY.toFixed(0)}`, 'info');
                debugLog(`  Final Position: left=${(offsetX + centerX).toFixed(0)}px, top=${(offsetY + centerY).toFixed(0)}px`, 'info');

                // Verify what was actually applied
                debugLog(`  Applied CSS: width=${img.style.width}, height=${img.style.height}, left=${img.style.left}, top=${img.style.top}`, 'info');

                // Check actual rendered size
                setTimeout(() => {
                    const renderedW = img.offsetWidth;
                    const renderedH = img.offsetHeight;
                    const computedStyle = window.getComputedStyle(img);
                    debugLog(`  ACTUAL RENDERED: ${renderedW}x${renderedH}`, 'info');
                    debugLog(`  COMPUTED STYLE: width=${computedStyle.width}, height=${computedStyle.height}`, 'info');

                    // Check computed position
                    const computedLeft = computedStyle.left;
                    const computedTop = computedStyle.top;
                    debugLog(`  COMPUTED POSITION: left=${computedLeft}, top=${computedTop}`, 'info');

                    // Check bounding rect (actual position on screen)
                    const rect = img.getBoundingClientRect();
                    debugLog(`  BOUNDING RECT: x=${rect.x.toFixed(0)}, y=${rect.y.toFixed(0)}, width=${rect.width.toFixed(0)}, height=${rect.height.toFixed(0)}`, 'info');

                    // Check container
                    const containerRect = container.getBoundingClientRect();
                    debugLog(`  CONTAINER RECT: x=${containerRect.x.toFixed(0)}, y=${containerRect.y.toFixed(0)}, width=${containerRect.width.toFixed(0)}, height=${containerRect.height.toFixed(0)}`, 'info');

                    // Check if image is visible
                    const containerStyle = window.getComputedStyle(container);
                    debugLog(`  CONTAINER overflow=${containerStyle.overflow}, position=${containerStyle.position}`, 'info');

                    // Check the slide parent
                    const slide = container.parentElement;
                    if (slide) {
                        const slideRect = slide.getBoundingClientRect();
                        const slideStyle = window.getComputedStyle(slide);
                        debugLog(`  SLIDE RECT: x=${slideRect.x.toFixed(0)}, y=${slideRect.y.toFixed(0)}, width=${slideRect.width.toFixed(0)}, height=${slideRect.height.toFixed(0)}`, 'info');
                        debugLog(`  SLIDE position=${slideStyle.position}, display=${slideStyle.display}, opacity=${slideStyle.opacity}`, 'info');
                        debugLog(`  SLIDE has class 'active': ${slide.classList.contains('active')}`, 'info');
                    }

                    // Check slideshow container
                    const slideshowContainer = document.getElementById('slideshow-container');
                    if (slideshowContainer) {
                        const scRect = slideshowContainer.getBoundingClientRect();
                        debugLog(`  SLIDESHOW-CONTAINER RECT: x=${scRect.x.toFixed(0)}, y=${scRect.y.toFixed(0)}, width=${scRect.width.toFixed(0)}, height=${scRect.height.toFixed(0)}`, 'info');
                    }

                    if (renderedW !== Math.round(scaledImgW) || renderedH !== Math.round(scaledImgH)) {
                        debugLog(`  ERROR: Rendered size doesn't match! Expected ${Math.round(scaledImgW)}x${Math.round(scaledImgH)}`, 'error');
                    }
                }, 100);

                // Check if crop overflows or has black bars
                if (scaledCropW > viewportW) {
                    debugLog(`  Width: Crop OVERFLOWS by ${(scaledCropW - viewportW).toFixed(0)}px (${((scaledCropW - viewportW) / 2).toFixed(0)}px hidden on each side) - GOOD, fills width`, 'info');
                } else if (scaledCropW < viewportW) {
                    debugLog(`  Width: BLACK BARS ${(viewportW - scaledCropW).toFixed(0)}px total (${((viewportW - scaledCropW) / 2).toFixed(0)}px on each side) - crop too narrow`, 'error');
                } else {
                    debugLog(`  Width: EXACT FIT - no black bars`, 'info');
                }

                if (scaledCropH > viewportH) {
                    debugLog(`  Height: Crop OVERFLOWS by ${(scaledCropH - viewportH).toFixed(0)}px (${((scaledCropH - viewportH) / 2).toFixed(0)}px hidden on top/bottom) - GOOD, fills height`, 'info');
                } else if (scaledCropH < viewportH) {
                    debugLog(`  Height: BLACK BARS ${(viewportH - scaledCropH).toFixed(0)}px total (${((viewportH - scaledCropH) / 2).toFixed(0)}px on top/bottom) - crop too short`, 'error');
                } else {
                    debugLog(`  Height: EXACT FIT - no black bars`, 'info');
                }

                // What we expect vs what we have
                const expectedBlackBars = scaledCropW >= viewportW && scaledCropH >= viewportH ? 'NONE - crop should fill entire screen' :
                                         scaledCropW >= viewportW ? 'Top/Bottom only' :
                                         scaledCropH >= viewportH ? 'Left/Right only' : 'ERROR: Black bars on all sides!';
                debugLog(`  EXPECTED: ${expectedBlackBars}`, 'info');

                // Calculate what part of the scaled image is visible through the viewport
                // When an image is positioned at top=-1704, pixels 1704 onwards are visible
                const imgTopPos = offsetY + centerY;  // Actual top position of image
                const imgLeftPos = offsetX + centerX;  // Actual left position of image

                // Calculate visible region in scaled image coordinates
                const visibleTop = imgTopPos < 0 ? -imgTopPos : 0;  // If image is shifted up, we see that many pixels down
                const visibleBottom = visibleTop + viewportH;
                const visibleLeft = imgLeftPos < 0 ? -imgLeftPos : 0;
                const visibleRight = visibleLeft + viewportW;

                debugLog(`  ===== DETAILED CROP ANALYSIS =====`, 'info');
                debugLog(`  Image Position: left=${imgLeftPos.toFixed(0)}px, top=${imgTopPos.toFixed(0)}px`, 'info');
                debugLog(`  Visible Region of ${scaledImgW.toFixed(0)}x${scaledImgH.toFixed(0)} scaled image:`, 'info');
                debugLog(`    X: ${visibleLeft.toFixed(0)} to ${visibleRight.toFixed(0)} (width: ${(visibleRight - visibleLeft).toFixed(0)}px)`, 'info');
                debugLog(`    Y: ${visibleTop.toFixed(0)} to ${visibleBottom.toFixed(0)} (height: ${(visibleBottom - visibleTop).toFixed(0)}px)`, 'info');

                // Show expected crop region in scaled coordinates
                const expectedCropTop = cropY * scale;
                const expectedCropBottom = expectedCropTop + (cropH * scale);
                const expectedCropLeft = cropX * scale;
                const expectedCropRight = expectedCropLeft + (cropW * scale);

                debugLog(`  Expected Crop Region in scaled image:`, 'info');
                debugLog(`    X: ${expectedCropLeft.toFixed(0)} to ${expectedCropRight.toFixed(0)} (width: ${(expectedCropRight - expectedCropLeft).toFixed(0)}px)`, 'info');
                debugLog(`    Y: ${expectedCropTop.toFixed(0)} to ${expectedCropBottom.toFixed(0)} (height: ${(expectedCropBottom - expectedCropTop).toFixed(0)}px)`, 'info');

                // Check if visible matches expected
                const topDiff = Math.abs(visibleTop - expectedCropTop);
                const bottomDiff = Math.abs(visibleBottom - expectedCropBottom);
                const leftDiff = Math.abs(visibleLeft - expectedCropLeft);
                const rightDiff = Math.abs(visibleRight - expectedCropRight);

                if (topDiff > 1 || bottomDiff > 1 || leftDiff > 1 || rightDiff > 1) {
                    debugLog(`  âŒ MISMATCH DETECTED:`, 'error');
                    if (topDiff > 1) debugLog(`    Top: visible ${visibleTop.toFixed(0)} vs expected ${expectedCropTop.toFixed(0)} (diff: ${topDiff.toFixed(0)}px)`, 'error');
                    if (bottomDiff > 1) debugLog(`    Bottom: visible ${visibleBottom.toFixed(0)} vs expected ${expectedCropBottom.toFixed(0)} (diff: ${bottomDiff.toFixed(0)}px)`, 'error');
                    if (leftDiff > 1) debugLog(`    Left: visible ${visibleLeft.toFixed(0)} vs expected ${expectedCropLeft.toFixed(0)} (diff: ${leftDiff.toFixed(0)}px)`, 'error');
                    if (rightDiff > 1) debugLog(`    Right: visible ${visibleRight.toFixed(0)} vs expected ${expectedCropRight.toFixed(0)} (diff: ${rightDiff.toFixed(0)}px)`, 'error');

                    debugLog(`  ðŸ” DIAGNOSIS: We are showing the WRONG part of the image!`, 'error');
                    if (visibleTop > expectedCropTop) {
                        debugLog(`    The image needs to be shifted DOWN by ${(visibleTop - expectedCropTop).toFixed(0)}px`, 'error');
                    } else if (visibleTop < expectedCropTop) {
                        debugLog(`    The image needs to be shifted UP by ${(expectedCropTop - visibleTop).toFixed(0)}px`, 'error');
                    }
                } else {
                    debugLog(`  âœ… MATCH: Visible region matches expected crop region!`, 'info');
                }
            };

            // Apply immediately if already loaded, otherwise wait
            if (img.complete && img.naturalWidth > 0) {
                debugLog(`Image ${img.alt} already loaded, applying styles immediately`, 'info');
                applyStyles();
            } else {
                debugLog(`Image ${img.alt} not loaded yet, waiting for onload`, 'info');
                img.onload = applyStyles;
            }
        }

        // Report current image to server
        async function reportCurrentImage(imageName) {
            try {
                await fetch('/api/kiosk/current-image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ image_name: imageName })
                });
            } catch (error) {
                // Silently fail - not critical
            }
        }

        // Show specific slide
        function showSlide(index, instant = false) {
            const slides = document.querySelectorAll('.slide');

            if (instant) {
                // Instant transition: disable transition FIRST, then change properties
                // Step 1: Disable transitions on all slides
                slides.forEach(slide => {
                    slide.style.transition = 'none';
                });
                // Force reflow to ensure transition: none is applied
                slides[0].offsetHeight;

                // Step 2: Now hide all slides
                slides.forEach(slide => {
                    slide.style.display = 'none';
                    slide.style.opacity = '0';
                    slide.classList.remove('active');
                });

                // Step 3: Show the target slide
                if (slides[index]) {
                    slides[index].style.display = 'flex';
                    slides[index].style.opacity = '1';
                    slides[index].classList.add('active');
                    currentIndex = index;

                    // Report current image to server
                    if (images[index]) {
                        reportCurrentImage(images[index].name);
                    }

                    // Check if this slide has a cropped image and reapply crop
                    const cropContainer = slides[index].querySelector('div[style*="overflow: hidden"]');
                    if (cropContainer) {
                        const img = cropContainer.querySelector('img');
                        const imageName = img.alt;
                        const cropData = imageCrops[imageName];

                        if (cropData) {
                            debugLog(`Reapplying crop for ${imageName} when showing slide`, 'info');
                            applyCrop(img, cropContainer, cropData);
                        }
                    }
                }
            } else {
                // Normal transition: use CSS classes with opacity transition
                // Clear any inline styles first
                slides.forEach(slide => {
                    slide.style.transition = '';
                    slide.style.display = '';
                    slide.style.opacity = '';
                    slide.classList.remove('active');
                });

                // Show current slide
                if (slides[index]) {
                    slides[index].classList.add('active');
                    currentIndex = index;

                    // Report current image to server
                    if (images[index]) {
                        reportCurrentImage(images[index].name);
                    }

                    // Check if this slide has a cropped image and reapply crop
                    const cropContainer = slides[index].querySelector('div[style*="overflow: hidden"]');
                    if (cropContainer) {
                        const img = cropContainer.querySelector('img');
                        const imageName = img.alt;
                        const cropData = imageCrops[imageName];

                        if (cropData) {
                            debugLog(`Reapplying crop for ${imageName} when showing slide`, 'info');
                            applyCrop(img, cropContainer, cropData);
                        }
                    }
                }
            }
        }

        // Next slide
        async function nextSlide(instant = false) {
            debugLog(`nextSlide called: currentIndex=${currentIndex}, images.length=${images.length}, last=${currentIndex === images.length - 1}`, 'debug');

            // Check if we're at the last image and about to loop
            if (currentIndex === images.length - 1 && images.length > 0) {
                // We're about to loop back to the beginning
                // Reshuffle the images, avoiding the current (last) image as the new first image
                const lastImageName = images[currentIndex]?.name;

                debugLog(`Reached end of slideshow, reshuffling. Avoiding ${lastImageName} as first image.`, 'info');

                try {
                    // Call reshuffle API
                    const response = await fetch('/api/kiosk/reshuffle', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            avoid_first: lastImageName
                        })
                    });

                    if (!response.ok) {
                        debugLog(`Reshuffle API error: ${response.status} ${response.statusText}`, 'error');
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const result = await response.json();
                    debugLog(`Reshuffle API response: ${JSON.stringify(result)}`, 'debug');

                    if (result.success) {
                        debugLog(`Reshuffled with new shuffle_id: ${result.shuffle_id}`, 'info');

                        // Reload images with new shuffle
                        await loadImages(0);  // Start from first image (index 0)

                        // Restart slideshow if not paused
                        if (!isPaused) {
                            startSlideshow();
                        }
                        return;
                    } else {
                        debugLog(`Reshuffle returned success=false`, 'error');
                    }
                } catch (error) {
                    debugLog(`Error reshuffling: ${error.message}`, 'error');
                    // Fall through to normal behavior if reshuffle fails
                }
            }

            // Normal advancement (or fallback if reshuffle failed)
            debugLog(`Normal slide advancement: ${currentIndex} -> ${(currentIndex + 1) % images.length}`, 'debug');
            currentIndex = (currentIndex + 1) % images.length;
            showSlide(currentIndex, instant);
        }

        // Previous slide
        function prevSlide(instant = false) {
            currentIndex = (currentIndex - 1 + images.length) % images.length;
            showSlide(currentIndex, instant);
        }

        // Start automatic slideshow
        function startSlideshow() {
            if (slideTimer) {
                clearInterval(slideTimer);
            }

            slideTimer = setInterval(nextSlide, interval);
        }

        // Toggle between cover (default, fills screen) and contain (shows full image)
        function toggleFillMode() {
            fillMode = !fillMode;
            const slides = document.querySelectorAll('.slide');
            slides.forEach(slide => {
                if (fillMode) {
                    slide.classList.add('contain-mode');
                } else {
                    slide.classList.remove('contain-mode');
                }
            });

            // Also update extra image overlay if present
            const extraOverlay = document.querySelector('.extra-image-overlay');
            if (extraOverlay) {
                extraOverlay.style.backgroundSize = fillMode ? 'contain' : 'cover';
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    nextSlide(true); // Instant transition for keyboard control
                    // Only restart timer if not paused
                    if (!isPaused) {
                        startSlideshow();
                    }
                    break;
                case 'ArrowLeft':
                    prevSlide(true); // Instant transition for keyboard control
                    // Only restart timer if not paused
                    if (!isPaused) {
                        startSlideshow();
                    }
                    break;
                case 'f':
                case 'F':
                    toggleFillMode();
                    break;
                case 'r':
                case 'R':
                    location.reload();
                    break;
            }
        });

        // Poll for remote control commands
        let isPaused = false;

        // Removed pollRemoteControl - now using WebSocket events

        // Execute remote command
        async function executeCommand(command) {
            // Handle jump_extra command (display extra image temporarily)
            if (typeof command === 'object' && command.command === 'jump_extra') {
                const imageName = command.image_name;
                await debugLog(`Displaying extra image: ${imageName}`, 'info');

                const container = document.getElementById('slideshow-container');

                // Remove any existing extra image overlay first
                const existingOverlay = container.querySelector('.extra-image-overlay');
                if (existingOverlay) {
                    existingOverlay.remove();
                }

                // Hide all existing slides (only if not already hidden)
                const allSlides = container.querySelectorAll('.slide:not(.extra-image-overlay)');
                allSlides.forEach(s => {
                    s.style.opacity = '0';
                    s.style.pointerEvents = 'none';
                });

                // Create a temporary overlay slide for the extra image
                const extraSlide = document.createElement('div');
                extraSlide.className = 'slide extra-image-overlay';
                extraSlide.style.position = 'absolute';
                extraSlide.style.top = '0';
                extraSlide.style.left = '0';
                extraSlide.style.width = '100%';
                extraSlide.style.height = '100%';
                extraSlide.style.opacity = '1';
                extraSlide.style.zIndex = '1000';

                // Check if this extra image has a crop
                const cropData = imageCrops[imageName];

                if (cropData) {
                    debugLog(`Applying crop to extra image: ${imageName}`, 'info');
                    extraSlide.classList.add('has-crop');

                    // Create cropped image using a container (same as regular slides)
                    const cropContainer = document.createElement('div');
                    cropContainer.style.width = '100%';
                    cropContainer.style.height = '100%';
                    cropContainer.style.overflow = 'hidden';
                    cropContainer.style.position = 'absolute';
                    cropContainer.style.top = '0';
                    cropContainer.style.left = '0';

                    const img = document.createElement('img');
                    img.src = `/extra-images/${encodeURIComponent(imageName)}`;
                    img.alt = imageName;
                    img.className = 'cropped';

                    cropContainer.appendChild(img);
                    extraSlide.appendChild(cropContainer);

                    // Apply crop when image loads
                    img.onload = () => applyCrop(img, cropContainer, cropData);
                } else {
                    // No crop - use background-image approach
                    extraSlide.style.backgroundImage = `url('/extra-images/${encodeURIComponent(imageName)}')`;
                    extraSlide.style.backgroundSize = fillMode ? 'contain' : 'cover';
                    extraSlide.style.backgroundPosition = 'center';
                    extraSlide.style.backgroundRepeat = 'no-repeat';
                }

                // Apply fillMode class if needed (for non-cropped images)
                if (fillMode && !cropData) {
                    extraSlide.classList.add('contain-mode');
                }

                container.appendChild(extraSlide);

                // Pause the slideshow
                if (slideTimer) {
                    clearInterval(slideTimer);
                    slideTimer = null;
                    isPaused = true;
                }

                return;
            }

            // Handle jump command (object with command and image_name)
            if (typeof command === 'object' && command.command === 'jump') {
                const imageName = command.image_name;
                const imageIndex = images.findIndex(img => img.name === imageName);
                if (imageIndex !== -1) {
                    // Image found in current array, jump to it (instant transition)
                    showSlide(imageIndex, true);
                    // Restart slideshow if not paused
                    if (!isPaused) {
                        startSlideshow();
                    }
                } else {
                    // Image not found (likely newly uploaded), reload with this image
                    await debugLog(`Image ${imageName} not in current list, reloading...`, 'info');
                    await loadImages(0, imageName);
                }
                return;
            }

            // Handle string commands
            switch(command) {
                case 'next':
                    nextSlide(true); // Instant transition for remote control
                    // Only restart slideshow if not paused
                    if (!isPaused) {
                        startSlideshow();
                    }
                    break;
                case 'prev':
                    prevSlide(true); // Instant transition for remote control
                    // Only restart slideshow if not paused
                    if (!isPaused) {
                        startSlideshow();
                    }
                    break;
                case 'pause':
                    if (slideTimer) {
                        clearInterval(slideTimer);
                        slideTimer = null;
                        isPaused = true;
                    }
                    break;
                case 'play':
                    // Remove extra image overlay if present
                    const extraOverlay = document.querySelector('.extra-image-overlay');
                    if (extraOverlay) {
                        extraOverlay.remove();
                        // Show the current slide
                        const currentSlide = document.querySelector(`.slide[data-index="${currentIndex}"]`);
                        if (currentSlide) {
                            currentSlide.style.opacity = '1';
                            currentSlide.style.pointerEvents = 'auto';
                        }
                    }
                    isPaused = false;
                    startSlideshow();
                    break;
                case 'reload':
                    isPaused = false; // Resume playback on reload
                    await reloadSlideshow();
                    break;
                case 'resume_from_extra':
                    // Remove extra image overlay if present
                    const extraOverlay2 = document.querySelector('.extra-image-overlay');
                    if (extraOverlay2) {
                        extraOverlay2.remove();
                    }

                    // Show the current slide
                    const currentSlide2 = document.querySelector(`.slide[data-index="${currentIndex}"]`);
                    if (currentSlide2) {
                        currentSlide2.style.opacity = '1';
                        currentSlide2.style.pointerEvents = 'auto';
                    } else {
                        // Try to show any slide as fallback
                        const anySlide = document.querySelector('.slide:not(.extra-image-overlay)');
                        if (anySlide) {
                            anySlide.style.opacity = '1';
                            anySlide.style.pointerEvents = 'auto';
                        }
                    }

                    isPaused = false;
                    startSlideshow();
                    break;
            }
        }

        // WebSocket event handlers
        socket.on('connect', () => {
            debugLog('WebSocket connected', 'info');
        });

        socket.on('disconnect', () => {
            debugLog('WebSocket disconnected', 'warn');
        });

        socket.on('reconnect', (attemptNumber) => {
            debugLog(`WebSocket reconnected after ${attemptNumber} attempts`, 'info');
            // Reload to ensure we have latest state
            checkForImageChanges();
        });

        socket.on('remote_command', (command) => {
            executeCommand(command);
        });

        socket.on('settings_update', (settings) => {
            debugLog('Settings updated via WebSocket', 'info');
            checkForImageChanges();
        });

        socket.on('image_list_changed', () => {
            debugLog('Image list changed via WebSocket', 'info');
            checkForImageChanges();
        });

        // Send initial debug message
        debugLog('Kiosk display starting... (I=' + (interval/1000) + 's, C=' + (checkInterval/1000) + 's)', 'info');
        debugLog(`Screen resolution: ${window.screen.width}x${window.screen.height}`, 'info');
        debugLog(`Window inner size: ${window.innerWidth}x${window.innerHeight}`, 'info');
        debugLog(`Window outer size: ${window.outerWidth}x${window.outerHeight}`, 'info');
        debugLog(`Device pixel ratio: ${window.devicePixelRatio}`, 'info');

        // Parse URL parameters for starting image and fit mode
        const urlParams = new URLSearchParams(window.location.search);
        const startImage = urlParams.get('image');
        const fitParam = urlParams.get('fit');

        // Set fillMode based on URL parameter (for external web clients)
        if (fitParam === 'true') {
            fillMode = true;
            debugLog('External client detected: starting in FIT mode', 'info');
        }

        // Load images on page load
        if (startImage) {
            debugLog(`URL parameter: starting with image ${startImage}`, 'info');
            loadImages(0, startImage);
        } else {
            loadImages();
        }
    </script>
</body>
</html>
