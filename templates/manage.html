<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiosk Image Management</title>

    <!-- Cropper.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000000;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #1a1a1a;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(255, 255, 255, 0.1);
            padding: 30px;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #aaaaaa;
            margin-bottom: 30px;
        }

        .navigation {
            display: flex;
            gap: 0;
            margin-bottom: 30px;
            border-bottom: 2px solid #333333;
        }

        .nav-link {
            padding: 12px 24px;
            text-decoration: none;
            color: #aaaaaa;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            font-weight: 500;
        }

        .nav-link:hover {
            color: #ffffff;
            background: #2a2a2a;
        }

        .nav-link.active {
            color: #ffffff;
            border-bottom-color: #2196F3;
        }

        .nav-link.view-kiosk {
            margin-left: auto;
            color: #4CAF50;
        }

        .nav-link.view-kiosk:hover {
            color: #66BB6A;
            background: transparent;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #333333;
            padding-bottom: 10px;
        }

        .settings-form {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .settings-form label {
            font-weight: 500;
            color: #cccccc;
        }

        .settings-form input[type="number"] {
            padding: 8px 12px;
            border: 1px solid #444444;
            border-radius: 4px;
            font-size: 14px;
            width: 100px;
            background: #2a2a2a;
            color: #ffffff;
        }

        .settings-form input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .settings-form button {
            background: #2196F3;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .settings-form button:hover {
            background: #1976D2;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .image-card {
            border: 1px solid #333333;
            border-radius: 8px;
            overflow: visible;
            background: #2a2a2a;
            transition: transform 0.2s, box-shadow 0.2s, border 0.2s;
            position: relative;
        }

        .image-card.active {
            border: 3px solid #FF9800;
        }

        /* Image clipping container */
        .image-clip-container {
            overflow: hidden;
            border-radius: 8px 8px 0 0;
            width: 100%;
            height: 200px;
            position: relative;
        }

        /* Keep image area clipped to rounded corners */
        .image-card > img {
            border-radius: 8px 8px 0 0;
        }

        /* Container div that wraps cropped images */
        .image-card > div[style*="overflow: hidden"] {
            overflow: hidden !important;
            border-radius: 8px 8px 0 0;
        }

        .image-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .image-card.disabled {
            border: 1px solid #444444;
        }

        .image-card.disabled img {
            filter: grayscale(100%);
            opacity: 0.5;
        }

        .image-card.disabled .card-info,
        .image-card.disabled .image-tags {
            opacity: 0.5;
        }

        .image-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            background: #1a1a1a;
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
        }

        .image-card img:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }

        /* Hover effect for crop containers */
        .image-card > div[style*="overflow: hidden"]:hover img {
            filter: brightness(1.1);
        }

        /* Blue LED indicator for currently displayed image */
        .current-image-led {
            position: absolute;
            bottom: 8px;
            right: 8px;
            width: 12px;
            height: 12px;
            background: #2196F3;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.8), 0 0 16px rgba(33, 150, 243, 0.4);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .current-image-led.active {
            opacity: 1;
        }

        .image-checkbox-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(26, 26, 26, 0.9);
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 10;
        }

        .image-checkbox-container label {
            font-size: 12px;
            font-weight: 500;
            color: #ffffff;
            cursor: pointer;
            margin: 0;
        }

        .image-checkbox-container input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .image-card-info {
            padding: 12px;
        }

        .image-card-name {
            font-size: 14px;
            color: #ffffff;
            margin-bottom: 8px;
            word-break: break-all;
        }

        .image-card-size {
            font-size: 12px;
            color: #888888;
            margin-bottom: 12px;
        }

        .delete-button {
            background: #f44336;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }

        .delete-button:hover {
            background: #d32f2f;
        }

        .message {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }

        .message.success {
            background: #1b5e20;
            color: #a5d6a7;
            border: 1px solid #4caf50;
        }

        .message.error {
            background: #b71c1c;
            color: #ef9a9a;
            border: 1px solid #f44336;
        }

        .message.visible {
            display: block;
        }

        .links {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .links a {
            color: #64b5f6;
            text-decoration: none;
            font-weight: 500;
        }

        .links a:hover {
            text-decoration: underline;
        }


        .remote-control {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #ff9800;
            margin-bottom: 20px;
        }

        .remote-control h3 {
            color: #ffb74d;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .control-button {
            background: #ff9800;
            color: white;
            padding: 12px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .control-button:hover {
            background: #f57c00;
        }

        .control-button:active {
            transform: scale(0.95);
        }

        .control-button.danger {
            background: #f44336;
        }

        .control-button.danger:hover {
            background: #d32f2f;
        }

        .control-button.success {
            background: #4CAF50;
        }

        .control-button.success:hover {
            background: #45a049;
        }

        .control-button-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .led-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
            transition: background 0.3s;
        }

        .led-indicator.active {
            background: #2196F3;
            box-shadow: 0 0 8px #2196F3;
        }

        .time-period-card {
            padding: 15px;
            background: #2a2a2a;
            border: 1px solid #444444;
            border-radius: 8px;
        }

        .time-period-card.active {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }

        .theme-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #1e3a5f;
            border: 1px solid #2196F3;
            border-radius: 4px;
            font-size: 14px;
            color: #64b5f6;
        }

        .theme-badge.currently-displayed {
            border: 3px solid #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.4);
        }

        .theme-badge.active {
            background: #2196F3;
            color: white;
            border: 3px solid #FF9800;
        }

        .theme-badge .theme-name {
            cursor: pointer;
            font-weight: 500;
        }

        .theme-badge .theme-name:hover {
            text-decoration: underline;
        }

        .theme-badge button {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 12px;
        }

        .theme-badge button:hover {
            background: #d32f2f;
        }

        .image-themes {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .image-theme-tag {
            display: inline-block;
            padding: 3px 8px;
            background: #e3f2fd;
            color: #1565c0;
            border-radius: 3px;
            font-size: 11px;
        }

        .theme-selector {
            margin-top: 8px;
        }

        .theme-selector select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
            width: 100%;
        }

        /* Crop Modal */
        .crop-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .crop-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .crop-modal-content {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .crop-container {
            max-width: 800px;
            max-height: 600px;
            margin: 20px 0;
        }

        .crop-container img {
            max-width: 100%;
        }

        .crop-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 15px;
        }

        .crop-button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .crop-button.primary {
            background: #4CAF50;
            color: white;
        }

        .crop-button.primary:hover {
            background: #45a049;
        }

        .crop-button.secondary {
            background: #f44336;
            color: white;
        }

        .crop-button.secondary:hover {
            background: #da190b;
        }

        .crop-button.tertiary {
            background: #757575;
            color: white;
        }

        .crop-button.tertiary:hover {
            background: #616161;
        }

        .crop-image-button {
            background: #2196F3;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 8px;
        }

        /* Action menu styles */
        .action-menu-container {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 10;
        }

        .action-menu-button {
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid #444444;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            color: #ffffff;
            transition: background 0.2s;
        }

        .action-menu-button:hover {
            background: #2a2a2a;
            color: #ffffff;
        }

        .action-menu-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            margin-bottom: 4px;
            background: #2a2a2a;
            border: 1px solid #444444;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            min-width: 180px;
            z-index: 1000;
            display: none;
        }

        .action-menu-dropdown.show {
            display: block;
        }

        .menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #ffffff;
            transition: background 0.2s;
            position: relative;
        }

        .menu-item:hover {
            background: #3a3a3a;
        }

        .menu-item:first-child {
            border-radius: 4px 4px 0 0;
        }

        .menu-item:last-child {
            border-radius: 0 0 4px 4px;
        }

        .menu-item-danger {
            color: #f44336;
        }

        .menu-item-danger:hover {
            background: #ffebee;
        }

        .menu-item.has-submenu {
            padding-right: 32px;
        }

        .submenu-arrow {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #999;
        }

        .submenu {
            position: absolute;
            left: 100%;
            bottom: 0;
            margin-left: 4px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            min-width: 150px;
            display: none;
            z-index: 1001;
        }

        .submenu.show {
            display: block;
        }

        .submenu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            color: #333;
            transition: background 0.2s;
        }

        .submenu-item:hover {
            background: #f5f5f5;
        }

        .submenu-item:first-child {
            border-radius: 4px 4px 0 0;
        }

        .submenu-item:last-child {
            border-radius: 0 0 4px 4px;
        }

        .crop-image-button:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Kiosk Image Management</h1>

        <div class="navigation">
            <a href="/remote" class="nav-link">Remote</a>
            <a href="/" class="nav-link active">Manage</a>
            <a href="/upload" class="nav-link">Upload</a>
            <a href="/search" class="nav-link">Search Art</a>
            <a href="/extra-images" class="nav-link">Extra Images</a>
            <a href="/backup" class="nav-link">Backup</a>
            <a href="/debug" class="nav-link">Debug</a>
            <a href="/view?fit=true" class="nav-link view-kiosk" target="_blank">View Kiosk Display</a>
        </div>

        <div id="message" class="message"></div>

        <div class="section">
            <div style="border-bottom: 2px solid #333333; margin-bottom: 15px;"></div>

            <h3 style="margin-bottom: 15px; color: #ffffff; display: flex; align-items: center; gap: 10px;">
                Day Scheduling
                <label style="display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: normal; cursor: pointer;">
                    <input type="checkbox" id="day-scheduling-toggle" style="cursor: pointer; width: 18px; height: 18px;">
                    <span style="color: #aaaaaa;">Enable</span>
                </label>
            </h3>

            <div id="day-times-container" style="display: none;">
                <p style="color: #aaaaaa; margin-bottom: 15px; font-size: 14px;">
                    Configure atmospheres for each 2-hour time period. These 6 periods repeat after 12 hours (AM/PM mirror).<br>
                    <em>If no atmospheres are assigned to a time period, all images will be shown (like "All Images" theme).</em>
                </p>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <!-- Time 1 -->
                    <div class="time-period-card" data-time-id="1">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4 class="time-period-label" style="color: #ffffff; margin: 0;" data-time-id="1">Time 1: 6 AM - 8 AM</h4>
                            <button onclick="editTimePeriodAtmospheres('1')" style="padding: 6px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Edit</button>
                        </div>
                        <div class="time-atmospheres" id="time-1-atmospheres" style="color: #aaaaaa; font-size: 13px; min-height: 20px;">
                            No atmospheres assigned
                        </div>
                    </div>

                    <!-- Time 2 -->
                    <div class="time-period-card" data-time-id="2">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4 class="time-period-label" style="color: #ffffff; margin: 0;" data-time-id="2">Time 2: 8 AM - 10 AM</h4>
                            <button onclick="editTimePeriodAtmospheres('2')" style="padding: 6px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Edit</button>
                        </div>
                        <div class="time-atmospheres" id="time-2-atmospheres" style="color: #aaaaaa; font-size: 13px; min-height: 20px;">
                            No atmospheres assigned
                        </div>
                    </div>

                    <!-- Time 3 -->
                    <div class="time-period-card" data-time-id="3">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4 class="time-period-label" style="color: #ffffff; margin: 0;" data-time-id="3">Time 3: 10 AM - 12 PM</h4>
                            <button onclick="editTimePeriodAtmospheres('3')" style="padding: 6px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Edit</button>
                        </div>
                        <div class="time-atmospheres" id="time-3-atmospheres" style="color: #aaaaaa; font-size: 13px; min-height: 20px;">
                            No atmospheres assigned
                        </div>
                    </div>

                    <!-- Time 4 -->
                    <div class="time-period-card" data-time-id="4">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4 class="time-period-label" style="color: #ffffff; margin: 0;" data-time-id="4">Time 4: 12 PM - 2 PM</h4>
                            <button onclick="editTimePeriodAtmospheres('4')" style="padding: 6px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Edit</button>
                        </div>
                        <div class="time-atmospheres" id="time-4-atmospheres" style="color: #aaaaaa; font-size: 13px; min-height: 20px;">
                            No atmospheres assigned
                        </div>
                    </div>

                    <!-- Time 5 -->
                    <div class="time-period-card" data-time-id="5">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4 class="time-period-label" style="color: #ffffff; margin: 0;" data-time-id="5">Time 5: 2 PM - 4 PM</h4>
                            <button onclick="editTimePeriodAtmospheres('5')" style="padding: 6px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Edit</button>
                        </div>
                        <div class="time-atmospheres" id="time-5-atmospheres" style="color: #aaaaaa; font-size: 13px; min-height: 20px;">
                            No atmospheres assigned
                        </div>
                    </div>

                    <!-- Time 6 -->
                    <div class="time-period-card" data-time-id="6">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4 class="time-period-label" style="color: #ffffff; margin: 0;" data-time-id="6">Time 6: 4 PM - 6 PM</h4>
                            <button onclick="editTimePeriodAtmospheres('6')" style="padding: 6px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Edit</button>
                        </div>
                        <div class="time-atmospheres" id="time-6-atmospheres" style="color: #aaaaaa; font-size: 13px; min-height: 20px;">
                            No atmospheres assigned
                        </div>
                    </div>
                </div>

                <p style="color: #888; font-size: 12px; font-style: italic;">
                    Note: These 6 periods repeat after 12 hours. Evening/night (6 PM - 6 AM) mirrors the daytime settings.
                </p>
            </div>

            <div style="margin-bottom: 30px;"></div>

            <h3 style="margin-bottom: 15px; color: #ffffff;">Atmospheres</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 20px; align-items: center;">
                <button id="show-create-atmosphere-btn" style="background: #4CAF50; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">New Atmosphere</button>
                <input type="text" id="new-atmosphere-name" placeholder="Atmosphere name" style="padding: 8px 12px; border: 1px solid #444444; border-radius: 4px; flex: 1; display: none; background: #2a2a2a; color: #ffffff;">
            </div>

            <div id="atmospheres-list" style="display: flex; flex-wrap: wrap; gap: 10px;">
                <!-- Atmospheres will be loaded here -->
            </div>

            <div style="margin-bottom: 30px;"></div>

            <h3 style="margin-bottom: 15px; color: #ffffff;">Themes</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 20px; align-items: center;">
                <button id="show-create-theme-btn" style="background: #4CAF50; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">New Theme</button>
                <input type="text" id="new-theme-name" placeholder="Theme name" style="padding: 8px 12px; border: 1px solid #444444; border-radius: 4px; flex: 1; display: none; background: #2a2a2a; color: #ffffff;">
            </div>

            <div id="themes-list" style="display: flex; flex-wrap: wrap; gap: 10px;">
                <!-- Themes will be loaded here -->
            </div>
        </div>

        <div class="section">
            <h2 id="current-images-heading">Current Images</h2>
            <div class="image-grid" id="image-grid">
                <p style="color: #999;">Loading images...</p>
            </div>
        </div>

        <!-- Add Video Section -->
        <div class="section">
            <h2>Add Video</h2>
            <div>
                <input type="text" id="video-url-input" placeholder="Video URL (YouTube, etc.)" style="width: 400px; padding: 8px; margin-right: 10px;">
                <button onclick="addVideo()" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Add Video</button>
                <span style="color: #888; margin-left: 10px; font-size: 12px;">Videos appear mixed with images above</span>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // Initialize Socket.IO connection
        const socket = io();

        // Menu handling functions (define early for use in createImageCard)
        function toggleMenu(menuContainer) {
            const dropdown = menuContainer.querySelector('.action-menu-dropdown');
            const isOpen = dropdown.classList.contains('show');

            // Close all other menus first
            closeAllMenus();

            // Toggle this menu
            if (!isOpen) {
                dropdown.classList.add('show');
                // Raise the parent card's z-index so dropdown and submenu appear above other cards
                const card = menuContainer.closest('.image-card');
                if (card) {
                    card.style.zIndex = '1002';
                }
            }
        }

        function closeAllMenus() {
            document.querySelectorAll('.action-menu-dropdown.show').forEach(dropdown => {
                dropdown.classList.remove('show');
                // Reset the parent card's z-index
                const card = dropdown.closest('.image-card');
                if (card) {
                    card.style.zIndex = '';
                }
            });
        }

        // Close menus when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.action-menu-container')) {
                closeAllMenus();
            }
        });

        // Track current playback state
        let isPlaying = true; // Assume playing by default

        // Update LED indicators
        function updateLEDs() {
            // Update play/pause LEDs
            if (isPlaying) {
                document.getElementById('led-play').classList.add('active');
                document.getElementById('led-pause').classList.remove('active');
            } else {
                document.getElementById('led-play').classList.remove('active');
                document.getElementById('led-pause').classList.add('active');
            }
        }

        // Flash LED briefly for action buttons
        function flashLED(ledId) {
            const led = document.getElementById(ledId);
            led.classList.add('active');
            setTimeout(() => {
                led.classList.remove('active');
            }, 500);
        }

        // Send remote control command
        function sendCommand(command) {
            try {
                // Send command via WebSocket
                socket.emit('send_command', { command });

                // Update LED indicators based on command
                switch(command) {
                    case 'play':
                        isPlaying = true;
                        updateLEDs();
                        break;
                    case 'pause':
                        isPlaying = false;
                        updateLEDs();
                        break;
                    case 'prev':
                        flashLED('led-prev');
                        break;
                    case 'next':
                        flashLED('led-next');
                        break;
                    case 'reload':
                        isPlaying = true; // Reload resumes playback
                        updateLEDs();
                        flashLED('led-reload');
                        break;
                }
            } catch (error) {
                console.error('Error sending command:', error);
                showMessage('Error sending command', 'error');
            }
        }

        // Jump to specific image in kiosk display
        async function jumpToImage(imageName) {
            try {
                // If a video is playing, stop it first
                if (currentPlayingVideoId) {
                    await fetch('/api/videos/stop-mpv', { method: 'POST' });
                    currentPlayingVideoId = null;
                    // Wait for kiosk to fully reload after stopping video
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
                // Send jump command via WebSocket
                socket.emit('send_command', { command: 'jump', image_name: imageName });
                // Success - no message shown
            } catch (error) {
                console.error('Error jumping to image:', error);
                showMessage('Error jumping to image', 'error');
            }
        }

        // Load and display images
        async function loadImages() {
            try {
                const response = await fetch('/api/images?enabled_only=true');
                const images = await response.json();

                // Load crop settings
                const settingsResponse = await fetch('/api/settings');
                const settings = await settingsResponse.json();
                const imageCrops = settings.image_crops || {};

                const grid = document.getElementById('image-grid');
                const heading = document.getElementById('current-images-heading');
                grid.innerHTML = '';

                // Update heading based on day scheduling, active atmosphere, or theme
                if (daySchedulingEnabled && currentTimePeriod) {
                    // Day scheduling is active - show current time period's atmospheres
                    const currentTimeAtmospheres = get_active_atmospheres_for_time(currentTimePeriod);
                    if (currentTimeAtmospheres.length === 1) {
                        heading.textContent = `Current Images - Atmosphere: ${currentTimeAtmospheres[0]}`;
                    } else if (currentTimeAtmospheres.length > 1) {
                        heading.textContent = `Current Images - Atmospheres: ${currentTimeAtmospheres.join(', ')}`;
                    } else {
                        heading.textContent = 'Current Images - All Images';
                    }
                } else if (activeAtmosphere) {
                    heading.textContent = `Current Images - Atmosphere: ${activeAtmosphere}`;
                } else if (activeTheme && activeTheme !== 'All Images') {
                    heading.textContent = `Current Images - Theme: ${activeTheme}`;
                } else {
                    heading.textContent = activeTheme === 'All Images' ? 'Current Images - All Images' : 'Current Images';
                }

                if (images.length === 0) {
                    grid.innerHTML = '<p style="color: #999;">No enabled images in current selection</p>';
                    return;
                }

                // Items (images and videos) are already filtered and shuffled by backend
                images.forEach(item => {
                    let card;
                    if (item.type === 'video') {
                        card = createVideoCard(item);
                    } else {
                        const cropData = imageCrops[item.name];
                        card = createImageCard(item, cropData);
                    }
                    grid.appendChild(card);
                });
            } catch (error) {
                console.error('Error loading images:', error);
                showMessage('Error loading images', 'error');
            }
        }

        // Apply crop to thumbnail image
        function applyCropToThumbnail(img, container, cropData) {
            const containerW = container.clientWidth;
            const containerH = container.clientHeight; // 200px

            const cropX = cropData.x;
            const cropY = cropData.y;
            const cropW = cropData.width;
            const cropH = cropData.height;
            const imgW = cropData.imageWidth;
            const imgH = cropData.imageHeight;

            // Calculate scale to make crop region fill container (cover behavior)
            const scaleX = containerW / cropW;
            const scaleY = containerH / cropH;
            const scale = Math.max(scaleX, scaleY);

            // Calculate scaled image dimensions
            const scaledImgW = imgW * scale;
            const scaledImgH = imgH * scale;

            // Calculate scaled crop dimensions
            const scaledCropW = cropW * scale;
            const scaledCropH = cropH * scale;

            // Calculate position to place crop region
            const offsetX = -cropX * scale;
            const offsetY = -cropY * scale;

            // Center the crop region in container
            const centerX = (containerW - scaledCropW) / 2;
            const centerY = (containerH - scaledCropH) / 2;

            // Apply styles
            img.style.position = 'absolute';
            img.style.width = `${scaledImgW}px`;
            img.style.height = `${scaledImgH}px`;
            img.style.left = `${offsetX + centerX}px`;
            img.style.top = `${offsetY + centerY}px`;
            img.style.objectFit = 'fill';
            img.style.maxWidth = 'none';
            img.style.maxHeight = 'none';
        }

        // Create image card element
        function createImageCard(image, cropData) {
            const card = document.createElement('div');
            card.className = 'image-card';
            if (!image.enabled) {
                card.classList.add('disabled');
            }

            // If crop exists, create a container for the cropped image
            if (cropData) {
                const cropContainer = document.createElement('div');
                cropContainer.style.width = '100%';
                cropContainer.style.height = '200px';
                cropContainer.style.overflow = 'hidden';
                cropContainer.style.position = 'relative';
                cropContainer.style.background = '#f0f0f0';
                cropContainer.style.cursor = 'pointer';
                cropContainer.onclick = () => jumpToImage(image.name);
                cropContainer.title = 'Click to jump to this image in the kiosk display';

                const img = document.createElement('img');
                img.src = image.url;
                img.alt = image.name;
                img.style.cursor = 'pointer';

                // Apply crop when image loads
                img.onload = () => applyCropToThumbnail(img, cropContainer, cropData);

                cropContainer.appendChild(img);
                card.appendChild(cropContainer);
            } else {
                // No crop - show normal image in clipping container
                const clipContainer = document.createElement('div');
                clipContainer.className = 'image-clip-container';
                clipContainer.style.cursor = 'pointer';
                clipContainer.onclick = () => jumpToImage(image.name);
                clipContainer.title = 'Click to jump to this image in the kiosk display';

                const img = document.createElement('img');
                img.src = image.url;
                img.alt = image.name;

                clipContainer.appendChild(img);
                card.appendChild(clipContainer);
            }

            // Create checkbox container
            const checkboxContainer = document.createElement('div');
            checkboxContainer.className = 'image-checkbox-container';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = image.enabled;
            checkbox.id = `enable-${image.name}`;
            checkbox.onchange = () => toggleImageEnabled(image.name, checkbox.checked, card);

            const label = document.createElement('label');
            label.htmlFor = `enable-${image.name}`;
            label.textContent = 'Show';

            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(label);

            const info = document.createElement('div');
            info.className = 'image-card-info';

            // Theme tags
            const themesDiv = document.createElement('div');
            themesDiv.className = 'image-themes';
            (image.themes || []).forEach(themeName => {
                const tag = document.createElement('span');
                tag.className = 'image-theme-tag';
                tag.style.cursor = 'pointer';
                tag.title = 'Click to remove from theme';
                tag.textContent = themeName + ' ✕';
                tag.onclick = async () => {
                    const newThemes = (image.themes || []).filter(t => t !== themeName);
                    await updateImageThemes(image.name, newThemes);
                    await loadImages();
                };
                themesDiv.appendChild(tag);
            });

            // Action menu (three dots)
            const menuContainer = document.createElement('div');
            menuContainer.className = 'action-menu-container';

            const menuButton = document.createElement('button');
            menuButton.className = 'action-menu-button';
            menuButton.innerHTML = '⋮';
            menuButton.title = 'Actions';
            menuButton.onclick = (e) => {
                e.stopPropagation();
                toggleMenu(menuContainer);
            };

            const menuDropdown = document.createElement('div');
            menuDropdown.className = 'action-menu-dropdown';

            // Add to theme submenu
            if (Object.keys(availableThemes).length > 0) {
                const themeMenuItem = document.createElement('div');
                themeMenuItem.className = 'menu-item has-submenu';
                themeMenuItem.innerHTML = 'Add to theme <span class="submenu-arrow">▸</span>';

                const themeSubmenu = document.createElement('div');
                themeSubmenu.className = 'submenu';

                for (const themeName in availableThemes) {
                    if (!(image.themes || []).includes(themeName)) {
                        const themeOption = document.createElement('div');
                        themeOption.className = 'submenu-item';
                        themeOption.textContent = themeName;
                        themeOption.onclick = async (e) => {
                            e.stopPropagation();
                            const newThemes = [...(image.themes || []), themeName];
                            await updateImageThemes(image.name, newThemes);
                            await loadImages();
                        };
                        themeSubmenu.appendChild(themeOption);
                    }
                }

                themeMenuItem.appendChild(themeSubmenu);

                // Handle submenu hover interaction
                themeMenuItem.addEventListener('mouseenter', () => {
                    themeSubmenu.classList.add('show');
                });

                themeMenuItem.addEventListener('mouseleave', (e) => {
                    // Delay hiding to allow mouse movement to submenu
                    setTimeout(() => {
                        if (!themeSubmenu.matches(':hover')) {
                            themeSubmenu.classList.remove('show');
                        }
                    }, 100);
                });

                themeSubmenu.addEventListener('mouseleave', () => {
                    themeSubmenu.classList.remove('show');
                });

                menuDropdown.appendChild(themeMenuItem);
            }

            // Crop menu item
            const cropMenuItem = document.createElement('div');
            cropMenuItem.className = 'menu-item';
            cropMenuItem.textContent = 'Crop';
            cropMenuItem.onclick = (e) => {
                e.stopPropagation();
                closeAllMenus();
                openCropModal(image.name, image.url);
            };
            menuDropdown.appendChild(cropMenuItem);

            // Delete menu item
            const deleteMenuItem = document.createElement('div');
            deleteMenuItem.className = 'menu-item menu-item-danger';
            deleteMenuItem.textContent = 'Delete';
            deleteMenuItem.onclick = (e) => {
                e.stopPropagation();
                closeAllMenus();
                deleteImage(image.name);
            };
            menuDropdown.appendChild(deleteMenuItem);

            menuContainer.appendChild(menuButton);
            menuContainer.appendChild(menuDropdown);

            info.appendChild(themesDiv);

            card.appendChild(menuContainer);
            card.appendChild(checkboxContainer);
            // Image or crop container already appended above
            card.appendChild(info);

            // Add blue LED indicator for current image
            const led = document.createElement('div');
            led.className = 'current-image-led';
            led.dataset.imageName = image.name;
            card.appendChild(led);

            return card;
        }

        // Create video card element for slideshow integration
        function createVideoCard(video) {
            const card = document.createElement('div');
            card.className = 'image-card video-card';
            card.dataset.videoId = video.video_id;
            if (!video.enabled) {
                card.classList.add('disabled');
            }

            // Video container with thumbnail and play icon
            const videoContainer = document.createElement('div');
            videoContainer.style.width = '100%';
            videoContainer.style.height = '200px';
            videoContainer.style.overflow = 'hidden';
            videoContainer.style.position = 'relative';
            videoContainer.style.background = '#2a2a2a';
            videoContainer.style.display = 'flex';
            videoContainer.style.alignItems = 'center';
            videoContainer.style.justifyContent = 'center';
            videoContainer.style.zIndex = '1'; // Keep below action menu

            // Thumbnail
            const thumb = document.createElement('img');
            thumb.src = `/thumbnails/${video.video_id}.png`;
            thumb.style.width = '100%';
            thumb.style.height = '100%';
            thumb.style.objectFit = 'cover';
            thumb.style.position = 'absolute';
            thumb.onerror = () => { thumb.style.display = 'none'; };

            // Play icon overlay
            const playIcon = document.createElement('div');
            playIcon.style.fontSize = '48px';
            playIcon.style.position = 'relative';
            playIcon.style.zIndex = '1';
            playIcon.style.textShadow = '0 0 10px rgba(0,0,0,0.8)';
            playIcon.textContent = '▶';

            videoContainer.appendChild(thumb);
            videoContainer.appendChild(playIcon);
            card.appendChild(videoContainer);

            // Click on video to play it
            videoContainer.onclick = async () => {
                await playVideo(video.video_id);
            };
            videoContainer.style.cursor = 'pointer';

            // Enable/disable checkbox
            const checkboxContainer = document.createElement('label');
            checkboxContainer.className = 'enable-checkbox';
            checkboxContainer.title = 'Enable/disable video in slideshow';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = video.enabled;
            checkbox.onchange = async () => {
                await toggleVideoEnabled(video.video_id, checkbox.checked, card);
            };

            const label = document.createElement('span');
            label.textContent = video.enabled ? 'Enabled' : 'Disabled';
            checkbox.addEventListener('change', () => {
                label.textContent = checkbox.checked ? 'Enabled' : 'Disabled';
            });

            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(label);

            const info = document.createElement('div');
            info.className = 'image-card-info';

            // Theme tags
            const themesDiv = document.createElement('div');
            themesDiv.className = 'image-themes';
            (video.themes || []).forEach(themeName => {
                const tag = document.createElement('span');
                tag.className = 'image-theme-tag';
                tag.style.cursor = 'pointer';
                tag.title = 'Click to remove from theme';
                tag.textContent = themeName + ' ✕';
                tag.onclick = async () => {
                    const newThemes = (video.themes || []).filter(t => t !== themeName);
                    await updateVideoThemes(video.video_id, newThemes);
                    await loadImages();
                };
                themesDiv.appendChild(tag);
            });

            // Action menu (three dots)
            const menuContainer = document.createElement('div');
            menuContainer.className = 'action-menu-container';

            const menuButton = document.createElement('button');
            menuButton.className = 'action-menu-button';
            menuButton.innerHTML = '⋮';
            menuButton.title = 'Actions';
            menuButton.onclick = (e) => {
                e.stopPropagation();
                toggleMenu(menuContainer);
            };

            const menuDropdown = document.createElement('div');
            menuDropdown.className = 'action-menu-dropdown';

            // Add to theme submenu
            if (Object.keys(availableThemes).length > 0) {
                const themeMenuItem = document.createElement('div');
                themeMenuItem.className = 'menu-item has-submenu';
                themeMenuItem.innerHTML = 'Add to theme <span class="submenu-arrow">▸</span>';

                const themeSubmenu = document.createElement('div');
                themeSubmenu.className = 'submenu';

                for (const themeName in availableThemes) {
                    if (!(video.themes || []).includes(themeName)) {
                        const themeOption = document.createElement('div');
                        themeOption.className = 'submenu-item';
                        themeOption.textContent = themeName;
                        themeOption.onclick = async (e) => {
                            e.stopPropagation();
                            const newThemes = [...(video.themes || []), themeName];
                            await updateVideoThemes(video.video_id, newThemes);
                            await loadImages();
                        };
                        themeSubmenu.appendChild(themeOption);
                    }
                }

                themeMenuItem.appendChild(themeSubmenu);

                themeMenuItem.addEventListener('mouseenter', () => {
                    themeSubmenu.classList.add('show');
                });

                themeMenuItem.addEventListener('mouseleave', (e) => {
                    setTimeout(() => {
                        if (!themeSubmenu.matches(':hover')) {
                            themeSubmenu.classList.remove('show');
                        }
                    }, 100);
                });

                themeSubmenu.addEventListener('mouseleave', () => {
                    themeSubmenu.classList.remove('show');
                });

                menuDropdown.appendChild(themeMenuItem);
            }

            // Delete menu item
            const deleteMenuItem = document.createElement('div');
            deleteMenuItem.className = 'menu-item menu-item-danger';
            deleteMenuItem.textContent = 'Delete';
            deleteMenuItem.onclick = (e) => {
                e.stopPropagation();
                closeAllMenus();
                deleteVideo(video.video_id);
            };
            menuDropdown.appendChild(deleteMenuItem);

            menuContainer.appendChild(menuButton);
            menuContainer.appendChild(menuDropdown);

            info.appendChild(themesDiv);

            card.appendChild(menuContainer);
            card.appendChild(checkboxContainer);
            card.appendChild(info);

            return card;
        }

        // Update video themes
        async function updateVideoThemes(videoId, themes) {
            try {
                const response = await fetch(`/api/videos/${videoId}/themes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ themes })
                });
                if (!response.ok) {
                    showMessage('Error updating video themes', 'error');
                }
            } catch (error) {
                console.error('Error updating video themes:', error);
                showMessage('Error updating video themes', 'error');
            }
        }

        // Toggle video enabled state
        async function toggleVideoEnabled(videoId, enabled, cardElement) {
            try {
                const response = await fetch(`/api/videos/${videoId}/toggle`, {
                    method: 'POST'
                });

                if (response.ok) {
                    if (enabled) {
                        cardElement.classList.remove('disabled');
                    } else {
                        cardElement.classList.add('disabled');
                    }
                } else {
                    showMessage('Error toggling video', 'error');
                }
            } catch (error) {
                console.error('Error toggling video:', error);
                showMessage('Error toggling video', 'error');
            }
        }

        // Delete image
        async function deleteImage(filename) {
            if (!confirm(`Delete ${filename}?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/images/${encodeURIComponent(filename)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    showMessage('Image deleted successfully', 'success');
                    loadImages();
                } else {
                    showMessage('Error deleting image', 'error');
                }
            } catch (error) {
                console.error('Error deleting image:', error);
                showMessage('Error deleting image', 'error');
            }
        }

        // Toggle image enabled state
        async function toggleImageEnabled(filename, enabled, cardElement) {
            try {
                const response = await fetch(`/api/images/${encodeURIComponent(filename)}/toggle`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled })
                });

                if (response.ok) {
                    // Update visual state immediately
                    if (enabled) {
                        cardElement.classList.remove('disabled');
                    } else {
                        cardElement.classList.add('disabled');
                    }
                } else {
                    showMessage('Error updating image state', 'error');
                }
            } catch (error) {
                console.error('Error toggling image:', error);
                showMessage('Error updating image state', 'error');
            }
        }

        // Show message
        function showMessage(text, type) {
            const message = document.getElementById('message');
            message.textContent = text;
            message.className = `message ${type} visible`;

            setTimeout(() => {
                message.classList.remove('visible');
            }, 3000);
        }

        // Atmosphere management functions
        let availableAtmospheres = {};
        let activeAtmosphere = null;
        let atmosphereThemes = {};

        async function loadAtmospheres() {
            try {
                const response = await fetch('/api/atmospheres');
                const data = await response.json();
                availableAtmospheres = data.atmospheres;
                activeAtmosphere = data.active_atmosphere;
                atmosphereThemes = data.atmosphere_themes;

                // Get currently displayed atmospheres if Day scheduling is enabled
                let currentlyDisplayedAtmospheres = [];
                if (daySchedulingEnabled && currentTimePeriod) {
                    const currentTimeAtmospheres = get_active_atmospheres_for_time(currentTimePeriod);
                    currentlyDisplayedAtmospheres = currentTimeAtmospheres;
                }

                // Update atmospheres list
                const atmospheresList = document.getElementById('atmospheres-list');
                atmospheresList.innerHTML = '';

                for (const atmosphereName in availableAtmospheres) {
                    const atmosphere = availableAtmospheres[atmosphereName];
                    const intervalMinutes = (atmosphere.interval || 3600) / 60;
                    const themesInAtmosphere = atmosphereThemes[atmosphereName] || [];

                    const badge = document.createElement('div');
                    badge.className = 'theme-badge';
                    if (atmosphereName === activeAtmosphere && !daySchedulingEnabled) {
                        badge.classList.add('active');
                    }

                    // Highlight if currently displayed via Day scheduling
                    const isCurrentlyDisplayed = daySchedulingEnabled && currentlyDisplayedAtmospheres.includes(atmosphereName);
                    if (isCurrentlyDisplayed) {
                        badge.classList.add('currently-displayed');
                    }

                    badge.innerHTML = `
                        <span class="theme-name" data-atmosphere="${atmosphereName}">${atmosphereName}</span>
                        <div style="font-size: 11px; color: #666; margin-top: 3px;">${themesInAtmosphere.length} theme(s)</div>
                        <div style="display: flex; align-items: center; gap: 5px; margin-top: 5px;">
                            <button class="interval-display-btn" data-atmosphere="${atmosphereName}" style="padding: 6px 12px; font-size: 12px; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-family: inherit;">
                                ${intervalMinutes} min
                            </button>
                            <input type="number" class="interval-input" data-atmosphere="${atmosphereName}" value="${intervalMinutes}" min="1" max="1440" step="0.5" style="width: 80px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; display: none;">
                            <button onclick="editAtmosphereThemes('${atmosphereName}')" style="padding: 6px 12px; font-size: 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 500;">Themes</button>
                            ${atmosphereName !== 'All Images' ? '<button onclick="deleteAtmosphere(\'' + atmosphereName + '\')" style="padding: 6px 12px; font-size: 12px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit;">Delete</button>' : ''}
                        </div>
                    `;

                    // Add click handler for atmosphere name to activate atmosphere
                    const atmosphereNameSpan = badge.querySelector('.theme-name');
                    atmosphereNameSpan.addEventListener('click', () => {
                        setActiveAtmosphere(atmosphereName);
                    });

                    // Add click handler for interval button
                    const intervalBtn = badge.querySelector('.interval-display-btn');
                    const intervalInput = badge.querySelector('.interval-input');

                    intervalBtn.addEventListener('click', () => {
                        intervalBtn.style.display = 'none';
                        intervalInput.style.display = 'block';
                        intervalInput.focus();
                        intervalInput.select();
                    });

                    // Save on blur or enter key
                    intervalInput.addEventListener('blur', () => {
                        saveAtmosphereIntervalFromInput(atmosphereName, intervalInput, intervalBtn);
                    });

                    intervalInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            intervalInput.blur();
                        }
                    });

                    atmospheresList.appendChild(badge);
                }
            } catch (error) {
                console.error('Error loading atmospheres:', error);
            }
        }

        async function createAtmosphere() {
            const nameInput = document.getElementById('new-atmosphere-name');
            const createBtn = document.getElementById('show-create-atmosphere-btn');
            const name = nameInput.value.trim();

            if (!name) {
                showMessage('Please enter an atmosphere name', 'error');
                return;
            }

            try {
                const response = await fetch('/api/atmospheres', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                if (response.ok) {
                    nameInput.value = '';
                    nameInput.style.display = 'none';
                    createBtn.style.display = 'block';
                    await loadAtmospheres();
                    showMessage(`Atmosphere "${name}" created`, 'success');
                } else {
                    const error = await response.json();
                    showMessage(error.error || 'Error creating atmosphere', 'error');
                }
            } catch (error) {
                console.error('Error creating atmosphere:', error);
                showMessage('Error creating atmosphere', 'error');
            }
        }

        function hideCreateAtmosphereInput() {
            const nameInput = document.getElementById('new-atmosphere-name');
            const createBtn = document.getElementById('show-create-atmosphere-btn');
            nameInput.value = '';
            nameInput.style.display = 'none';
            createBtn.style.display = 'block';
        }

        async function saveAtmosphereIntervalFromInput(atmosphereName, inputElement, btnElement) {
            const intervalMinutes = parseFloat(inputElement.value);

            if (!intervalMinutes || intervalMinutes < 1) {
                showMessage('Invalid interval value', 'error');
                inputElement.style.display = 'none';
                btnElement.style.display = 'block';
                return;
            }

            const intervalSeconds = Math.round(intervalMinutes * 60);

            try {
                const response = await fetch(`/api/atmospheres/${encodeURIComponent(atmosphereName)}/interval`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval: intervalSeconds })
                });

                if (response.ok) {
                    availableAtmospheres[atmosphereName].interval = intervalSeconds;
                    btnElement.textContent = `${intervalMinutes} min`;
                    inputElement.style.display = 'none';
                    btnElement.style.display = 'block';
                    showMessage(`Interval updated for atmosphere "${atmosphereName}"`, 'success');
                } else {
                    showMessage('Error updating atmosphere interval', 'error');
                    inputElement.style.display = 'none';
                    btnElement.style.display = 'block';
                }
            } catch (error) {
                console.error('Error updating atmosphere interval:', error);
                showMessage('Error updating atmosphere interval', 'error');
                inputElement.style.display = 'none';
                btnElement.style.display = 'block';
            }
        }

        async function setActiveAtmosphere(atmosphereName) {
            try {
                const response = await fetch('/api/atmospheres/active', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ atmosphere_name: atmosphereName })
                });

                if (response.ok) {
                    activeAtmosphere = atmosphereName;

                    // Reload both atmospheres and themes to update active state
                    // Note: Theme badges won't show as active when an atmosphere is active
                    await loadAtmospheres();
                    await loadThemes();
                    await loadImages();
                } else {
                    showMessage('Error setting active atmosphere', 'error');
                }
            } catch (error) {
                console.error('Error setting active atmosphere:', error);
                showMessage('Error setting active atmosphere', 'error');
            }
        }

        async function deleteAtmosphere(atmosphereName) {
            if (!confirm(`Delete atmosphere "${atmosphereName}"?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/atmospheres/${encodeURIComponent(atmosphereName)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    await loadAtmospheres();
                    await loadImages();
                    showMessage(`Atmosphere "${atmosphereName}" deleted`, 'success');
                } else {
                    showMessage('Error deleting atmosphere', 'error');
                }
            } catch (error) {
                console.error('Error deleting atmosphere:', error);
                showMessage('Error deleting atmosphere', 'error');
            }
        }

        function editAtmosphereThemes(atmosphereName) {
            const themesInAtmosphere = atmosphereThemes[atmosphereName] || [];

            // Build checkboxes for all themes
            let themeCheckboxes = '';
            for (const themeName in availableThemes) {
                const checked = themesInAtmosphere.includes(themeName) ? 'checked' : '';
                themeCheckboxes += `
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" value="${themeName}" ${checked} style="cursor: pointer;">
                            <span>${themeName}</span>
                        </label>
                    </div>
                `;
            }

            const html = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;" id="atmosphere-themes-modal">
                    <div style="background: white; padding: 30px; border-radius: 8px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
                        <h3 style="margin-top: 0; margin-bottom: 20px;">Select Themes for "${atmosphereName}"</h3>
                        <div id="theme-checkboxes">
                            ${themeCheckboxes}
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="saveAtmosphereThemes('${atmosphereName}')" style="flex: 1; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Save</button>
                            <button onclick="closeAtmosphereThemesModal()" style="flex: 1; padding: 10px; background: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', html);
        }

        async function saveAtmosphereThemes(atmosphereName) {
            const checkboxes = document.querySelectorAll('#theme-checkboxes input[type="checkbox"]:checked');
            const selectedThemes = Array.from(checkboxes).map(cb => cb.value);

            try {
                const response = await fetch(`/api/atmospheres/${encodeURIComponent(atmosphereName)}/themes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ themes: selectedThemes })
                });

                if (response.ok) {
                    atmosphereThemes[atmosphereName] = selectedThemes;
                    closeAtmosphereThemesModal();
                    await loadAtmospheres();
                    await loadImages();
                    showMessage(`Themes updated for atmosphere "${atmosphereName}"`, 'success');
                } else {
                    showMessage('Error updating atmosphere themes', 'error');
                }
            } catch (error) {
                console.error('Error updating atmosphere themes:', error);
                showMessage('Error updating atmosphere themes', 'error');
            }
        }

        function closeAtmosphereThemesModal() {
            const modal = document.getElementById('atmosphere-themes-modal');
            if (modal) {
                modal.remove();
            }
        }

        // Day scheduling management functions
        let daySchedulingEnabled = false;
        let dayTimes = {};
        let currentTimePeriod = null;

        function get_active_atmospheres_for_time(timePeriod) {
            // Mirror map for times 7-12
            const mirrorMap = {
                '7': '1', '8': '2', '9': '3',
                '10': '4', '11': '5', '12': '6'
            };
            const sourceTime = mirrorMap[timePeriod] || timePeriod;
            const atmospheres = dayTimes[sourceTime]?.atmospheres || [];

            // If no atmospheres assigned, return 'All Images' as default
            if (atmospheres.length === 0) {
                return ['All Images'];
            }

            return atmospheres;
        }

        async function loadDayScheduling() {
            try {
                const response = await fetch('/api/day/status');
                const data = await response.json();
                daySchedulingEnabled = data.enabled;
                dayTimes = data.day_times;
                currentTimePeriod = data.current_time_period;

                // Update toggle checkbox
                const toggle = document.getElementById('day-scheduling-toggle');
                toggle.checked = daySchedulingEnabled;

                // Show/hide day times container
                const container = document.getElementById('day-times-container');
                container.style.display = daySchedulingEnabled ? 'block' : 'none';

                // Update time period displays
                updateTimePeriodDisplays();

                // Highlight current time period
                highlightCurrentTimePeriod();
            } catch (error) {
                console.error('Error loading day scheduling:', error);
            }
        }

        function updateTimePeriodDisplays() {
            // Update time labels based on current hour
            updateTimePeriodLabels();

            // Update all 6 time periods (times 7-12 mirror these)
            for (let i = 1; i <= 6; i++) {
                const timeId = i.toString();
                const atmospheres = dayTimes[timeId]?.atmospheres || [];
                const displayElement = document.getElementById(`time-${timeId}-atmospheres`);

                if (atmospheres.length === 0) {
                    displayElement.textContent = 'No atmospheres assigned';
                    displayElement.style.color = '#aaaaaa';
                } else {
                    displayElement.textContent = atmospheres.join(', ');
                    displayElement.style.color = '#ffffff';
                }
            }
        }

        function updateTimePeriodLabels() {
            // Determine if we're in AM cycle (6am-6pm) or PM cycle (6pm-6am)
            const now = new Date();
            const hour = now.getHours();
            const isPMCycle = hour >= 18 || hour < 6;

            // Time period definitions: [start_hour, end_hour, label]
            const timeRanges = [
                { id: 1, amLabel: '6 AM - 8 AM', pmLabel: '6 PM - 8 PM' },
                { id: 2, amLabel: '8 AM - 10 AM', pmLabel: '8 PM - 10 PM' },
                { id: 3, amLabel: '10 AM - 12 PM', pmLabel: '10 PM - 12 AM' },
                { id: 4, amLabel: '12 PM - 2 PM', pmLabel: '12 AM - 2 AM' },
                { id: 5, amLabel: '2 PM - 4 PM', pmLabel: '2 AM - 4 AM' },
                { id: 6, amLabel: '4 PM - 6 PM', pmLabel: '4 AM - 6 AM' }
            ];

            timeRanges.forEach(range => {
                const label = isPMCycle ? range.pmLabel : range.amLabel;
                const labelElement = document.querySelector(`.time-period-label[data-time-id="${range.id}"]`);
                if (labelElement) {
                    labelElement.textContent = `Time ${range.id}: ${label}`;
                }
            });
        }

        function highlightCurrentTimePeriod() {
            // Remove active class from all cards
            document.querySelectorAll('.time-period-card').forEach(card => {
                card.classList.remove('active');
            });

            if (!daySchedulingEnabled || !currentTimePeriod) return;

            // Map time periods 7-12 to their source 1-6
            const displayMap = {
                '1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6',
                '7': '1', '8': '2', '9': '3', '10': '4', '11': '5', '12': '6'
            };

            const displayTime = displayMap[currentTimePeriod];
            const card = document.querySelector(`.time-period-card[data-time-id="${displayTime}"]`);
            if (card) {
                card.classList.add('active');
            }
        }

        async function toggleDayScheduling() {
            const toggle = document.getElementById('day-scheduling-toggle');
            const enabled = toggle.checked;

            try {
                const response = await fetch('/api/day/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled })
                });

                if (response.ok) {
                    daySchedulingEnabled = enabled;
                    const container = document.getElementById('day-times-container');
                    container.style.display = enabled ? 'block' : 'none';

                    // Reload data to reflect changes
                    await loadDayScheduling();
                    await loadAtmospheres();
                    await loadThemes();
                    await loadImages();

                    showMessage(`Day scheduling ${enabled ? 'enabled' : 'disabled'}`, 'success');
                } else {
                    showMessage('Error toggling day scheduling', 'error');
                    toggle.checked = !enabled;
                }
            } catch (error) {
                console.error('Error toggling day scheduling:', error);
                showMessage('Error toggling day scheduling', 'error');
                toggle.checked = !enabled;
            }
        }

        function editTimePeriodAtmospheres(timeId) {
            const assignedAtmospheres = dayTimes[timeId]?.atmospheres || [];

            // Build checkboxes for all atmospheres
            let atmosphereCheckboxes = '';
            for (const atmosphereName in availableAtmospheres) {
                const checked = assignedAtmospheres.includes(atmosphereName) ? 'checked' : '';
                atmosphereCheckboxes += `
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" value="${atmosphereName}" ${checked} style="cursor: pointer;">
                            <span>${atmosphereName}</span>
                        </label>
                    </div>
                `;
            }

            // Get time period label
            const timeLabels = {
                '1': '6:00 AM - 8:00 AM',
                '2': '8:00 AM - 10:00 AM',
                '3': '10:00 AM - 12:00 PM',
                '4': '12:00 PM - 2:00 PM',
                '5': '2:00 PM - 4:00 PM',
                '6': '4:00 PM - 6:00 PM'
            };

            const html = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;" id="time-atmospheres-modal">
                    <div style="background: white; padding: 30px; border-radius: 8px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
                        <h3 style="margin-top: 0; margin-bottom: 20px;">Select Atmospheres for Time ${timeId} (${timeLabels[timeId]})</h3>
                        <div id="atmosphere-checkboxes">
                            ${atmosphereCheckboxes}
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="saveTimePeriodAtmospheres('${timeId}')" style="flex: 1; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Save</button>
                            <button onclick="closeTimePeriodAtmospheresModal()" style="flex: 1; padding: 10px; background: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', html);
        }

        async function saveTimePeriodAtmospheres(timeId) {
            const checkboxes = document.querySelectorAll('#atmosphere-checkboxes input[type="checkbox"]:checked');
            const selectedAtmospheres = Array.from(checkboxes).map(cb => cb.value);

            try {
                const response = await fetch(`/api/day/times/${timeId}/atmospheres`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ atmospheres: selectedAtmospheres })
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('Time period atmospheres updated:', result);
                    closeTimePeriodAtmospheresModal();

                    // Reload all data to update highlighting
                    await loadDayScheduling();
                    await loadAtmospheres();
                    await loadThemes();
                    await loadImages();

                    showMessage(`Atmospheres updated for Time ${timeId}`, 'success');
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    console.error('Error response:', errorData);
                    showMessage(`Error: ${errorData.error || 'Failed to update time period'}`, 'error');
                }
            } catch (error) {
                console.error('Error updating time period atmospheres:', error);
                showMessage(`Error updating time period atmospheres: ${error.message}`, 'error');
            }
        }

        function closeTimePeriodAtmospheresModal() {
            const modal = document.getElementById('time-atmospheres-modal');
            if (modal) {
                modal.remove();
            }
        }

        // Theme management functions
        let availableThemes = {};
        let activeTheme = null;

        async function loadThemes() {
            try {
                const response = await fetch('/api/themes');
                const data = await response.json();
                availableThemes = data.themes;
                activeTheme = data.active_theme;

                // Update themes list
                const themesList = document.getElementById('themes-list');
                themesList.innerHTML = '';

                // Separate permanent themes from user-created themes
                const permanentThemes = ['All Images', 'Extras'];
                const userThemes = Object.keys(availableThemes).filter(name => !permanentThemes.includes(name));

                // Create permanent themes row
                const permanentRow = document.createElement('div');
                permanentRow.style.display = 'flex';
                permanentRow.style.gap = '10px';
                permanentRow.style.marginBottom = '10px';
                permanentRow.style.width = '100%';

                permanentThemes.forEach(themeName => {
                    if (availableThemes[themeName]) {
                        const badge = createThemeBadge(themeName, availableThemes[themeName], true);
                        permanentRow.appendChild(badge);
                    }
                });

                themesList.appendChild(permanentRow);

                // Create user themes
                userThemes.forEach(themeName => {
                    const badge = createThemeBadge(themeName, availableThemes[themeName], false);
                    themesList.appendChild(badge);
                });
            } catch (error) {
                console.error('Error loading themes:', error);
            }
        }

        function createThemeBadge(themeName, theme, isPermanent) {
            const intervalMinutes = (theme.interval || 3600) / 60;

            const badge = document.createElement('div');
            badge.className = 'theme-badge';

            // Check if this theme is currently displayed
            let isCurrentlyDisplayed = false;
            if (daySchedulingEnabled && currentTimePeriod) {
                // Get atmospheres for current time period
                const currentTimeAtmospheres = get_active_atmospheres_for_time(currentTimePeriod);
                // Check if this theme is in any of those atmospheres
                for (const atmName of currentTimeAtmospheres) {
                    // "All Images" atmosphere only displays "All Images" theme
                    if (atmName === 'All Images') {
                        isCurrentlyDisplayed = (themeName === 'All Images');
                        break;
                    }
                    const atmThemes = atmosphereThemes[atmName] || [];
                    if (atmThemes.includes(themeName)) {
                        isCurrentlyDisplayed = true;
                        break;
                    }
                }
            }

            // Determine if theme should be shown as active
            let isActiveTheme = false;

            // When day scheduling is enabled, check if this theme is in the current time period's atmospheres
            if (daySchedulingEnabled && currentTimePeriod) {
                const currentTimeAtmospheres = get_active_atmospheres_for_time(currentTimePeriod);
                for (const atmName of currentTimeAtmospheres) {
                    if (atmName === 'All Images') {
                        // "All Images" atmosphere only shows "All Images" theme as active
                        isActiveTheme = (themeName === 'All Images');
                        break;
                    } else {
                        // Other atmospheres show their assigned themes as active
                        const atmThemes = atmosphereThemes[atmName] || [];
                        if (atmThemes.includes(themeName)) {
                            isActiveTheme = true;
                            break;
                        }
                    }
                }
            }
            // When day scheduling is disabled
            else if (!daySchedulingEnabled) {
                if (activeAtmosphere) {
                    if (activeAtmosphere === 'All Images') {
                        // "All Images" atmosphere only shows "All Images" theme as active
                        isActiveTheme = (themeName === 'All Images');
                    } else {
                        // Other atmospheres show their assigned themes as active
                        const atmThemes = atmosphereThemes[activeAtmosphere] || [];
                        isActiveTheme = atmThemes.includes(themeName);
                    }
                } else {
                    // No atmosphere active, show theme as active if it's the active theme
                    isActiveTheme = (themeName === activeTheme);
                }
            }

            // Show green border if currently displayed, otherwise show as active if selected
            if (isCurrentlyDisplayed) {
                badge.classList.add('currently-displayed');
            } else if (isActiveTheme) {
                badge.classList.add('active');
            }

            // Build HTML with conditional delete button
            badge.innerHTML = `
                <span class="theme-name" data-theme="${themeName}">${themeName}</span>
                <div style="display: flex; align-items: center; gap: 5px; margin-top: 5px;">
                    <button class="interval-display-btn" data-theme="${themeName}" style="padding: 6px 12px; font-size: 12px; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                        ${intervalMinutes} min
                    </button>
                    <input type="number" class="interval-input" data-theme="${themeName}" value="${intervalMinutes}" min="1" max="1440" step="0.5" style="width: 80px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; display: none;">
                    ${!isPermanent ? `<button onclick="deleteTheme('${themeName}')" style="padding: 6px 12px; font-size: 12px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>` : ''}
                </div>
            `;

            // Add click handler for theme name to activate theme
            const themeNameSpan = badge.querySelector('.theme-name');
            themeNameSpan.addEventListener('click', () => {
                setActiveThemeByName(themeName);
            });

            // Add click handler for interval button
            const intervalBtn = badge.querySelector('.interval-display-btn');
            const intervalInput = badge.querySelector('.interval-input');

            intervalBtn.addEventListener('click', () => {
                intervalBtn.style.display = 'none';
                intervalInput.style.display = 'block';
                intervalInput.focus();
                intervalInput.select();
            });

            // Save on blur or enter key
            intervalInput.addEventListener('blur', () => {
                saveThemeIntervalFromInput(themeName, intervalInput, intervalBtn);
            });

            intervalInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    intervalInput.blur();
                }
            });

            return badge;
        }

        async function createTheme() {
            const nameInput = document.getElementById('new-theme-name');
            const createBtn = document.getElementById('show-create-theme-btn');
            const name = nameInput.value.trim();

            if (!name) {
                showMessage('Please enter a theme name', 'error');
                return;
            }

            try {
                const response = await fetch('/api/themes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                if (response.ok) {
                    nameInput.value = '';
                    nameInput.style.display = 'none';
                    createBtn.style.display = 'block';
                    await loadThemes();
                    await loadImages(); // Reload to show theme selectors
                    showMessage(`Theme "${name}" created`, 'success');
                } else {
                    const error = await response.json();
                    showMessage(error.error || 'Error creating theme', 'error');
                }
            } catch (error) {
                console.error('Error creating theme:', error);
                showMessage('Error creating theme', 'error');
            }
        }

        function hideCreateThemeInput() {
            const nameInput = document.getElementById('new-theme-name');
            const createBtn = document.getElementById('show-create-theme-btn');
            nameInput.value = '';
            nameInput.style.display = 'none';
            createBtn.style.display = 'block';
        }

        async function saveThemeInterval(themeName) {
            const inputElement = document.getElementById(`interval-${themeName}`);
            const intervalMinutes = parseFloat(inputElement.value);

            if (!intervalMinutes || intervalMinutes < 1) {
                showMessage('Invalid interval value', 'error');
                return;
            }

            const intervalSeconds = Math.round(intervalMinutes * 60);

            try {
                const response = await fetch(`/api/themes/${encodeURIComponent(themeName)}/interval`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval: intervalSeconds })
                });

                if (response.ok) {
                    availableThemes[themeName].interval = intervalSeconds;
                    showMessage(`Interval updated for theme "${themeName}"`, 'success');
                } else {
                    showMessage('Error updating theme interval', 'error');
                }
            } catch (error) {
                console.error('Error updating theme interval:', error);
                showMessage('Error updating theme interval', 'error');
            }
        }

        async function saveThemeIntervalFromInput(themeName, inputElement, buttonElement) {
            const intervalMinutes = parseFloat(inputElement.value);

            if (!intervalMinutes || intervalMinutes < 1) {
                showMessage('Invalid interval value', 'error');
                inputElement.value = (availableThemes[themeName].interval || 3600) / 60;
                inputElement.style.display = 'none';
                buttonElement.style.display = 'block';
                return;
            }

            const intervalSeconds = Math.round(intervalMinutes * 60);

            try {
                const response = await fetch(`/api/themes/${encodeURIComponent(themeName)}/interval`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval: intervalSeconds })
                });

                if (response.ok) {
                    availableThemes[themeName].interval = intervalSeconds;
                    buttonElement.textContent = `${intervalMinutes} min`;
                    showMessage(`Interval updated for theme "${themeName}"`, 'success');
                } else {
                    showMessage('Error updating theme interval', 'error');
                    inputElement.value = (availableThemes[themeName].interval || 3600) / 60;
                }
            } catch (error) {
                console.error('Error updating theme interval:', error);
                showMessage('Error updating theme interval', 'error');
                inputElement.value = (availableThemes[themeName].interval || 3600) / 60;
            }

            // Switch back to button display
            inputElement.style.display = 'none';
            buttonElement.style.display = 'block';
        }

        async function deleteTheme(themeName) {
            if (!confirm(`Delete theme "${themeName}"? This will remove it from all images.`)) {
                return;
            }

            try {
                const response = await fetch(`/api/themes/${encodeURIComponent(themeName)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    await loadThemes();
                    await loadImages(); // Reload to update image cards
                    showMessage(`Theme "${themeName}" deleted`, 'success');
                } else {
                    showMessage('Error deleting theme', 'error');
                }
            } catch (error) {
                console.error('Error deleting theme:', error);
                showMessage('Error deleting theme', 'error');
            }
        }

        async function setActiveThemeByName(themeName) {
            if (!themeName) {
                showMessage('Please select a theme', 'error');
                return;
            }

            try {
                // Stop any currently playing video before switching themes
                await fetch('/api/videos/stop-mpv', { method: 'POST' });

                const response = await fetch('/api/themes/active', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ theme_name: themeName })
                });

                if (response.ok) {
                    activeTheme = themeName;
                    activeAtmosphere = null; // Backend clears this automatically

                    // Reload atmospheres and themes to update active state
                    await loadAtmospheres();
                    await loadThemes();

                    // Reload images to show filtered view
                    await loadImages();
                } else {
                    showMessage('Error setting active theme', 'error');
                }
            } catch (error) {
                console.error('Error setting active theme:', error);
                showMessage('Error setting active theme', 'error');
            }
        }

        async function updateImageThemes(imageName, themes) {
            try {
                const response = await fetch(`/api/images/${encodeURIComponent(imageName)}/themes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ themes })
                });

                if (!response.ok) {
                    showMessage('Error updating image themes', 'error');
                }
            } catch (error) {
                console.error('Error updating image themes:', error);
                showMessage('Error updating image themes', 'error');
            }
        }

        // Crop functionality
        let currentCropper = null;
        let currentCropImage = null;

        async function openCropModal(imageName, imageUrl) {
            currentCropImage = imageName;
            const modal = document.getElementById('crop-modal');
            const image = document.getElementById('crop-image');

            // Reset aspect ratio checkbox to checked (locked) by default
            const checkbox = document.getElementById('lock-aspect-ratio');
            checkbox.checked = true;

            // Set image source
            image.src = imageUrl;

            // Show modal
            modal.classList.add('active');

            // Wait for image to load
            await new Promise(resolve => {
                if (image.complete) {
                    resolve();
                } else {
                    image.onload = resolve;
                }
            });

            // Destroy existing cropper if any
            if (currentCropper) {
                currentCropper.destroy();
            }

            // Get existing crop data if any
            const settings = await fetch('/api/settings').then(r => r.json());
            const imageCrops = settings.image_crops || {};
            const cropData = imageCrops[imageName];

            // Initialize cropper
            const displayAspect = 2560 / 2880; // 0.889 - viewport aspect ratio

            currentCropper = new Cropper(image, {
                viewMode: 1,
                dragMode: 'move',
                aspectRatio: displayAspect, // Lock to display aspect ratio
                autoCropArea: 1,
                restore: false,
                guides: true,
                center: true,
                highlight: true,
                cropBoxMovable: true,
                cropBoxResizable: true,
                toggleDragModeOnDblclick: false,
                ready: function() {
                    // Set aspect ratio first to ensure it's locked
                    currentCropper.setAspectRatio(displayAspect);

                    // If crop data exists, set it
                    if (cropData) {
                        currentCropper.setData({
                            x: cropData.x,
                            y: cropData.y,
                            width: cropData.width,
                            height: cropData.height
                        });
                    } else {
                        // No existing crop - create default crop matching display aspect ratio
                        const imageData = currentCropper.getImageData();
                        const imgW = imageData.naturalWidth;
                        const imgH = imageData.naturalHeight;
                        const imgAspect = imgW / imgH;

                        let cropW, cropH, cropX, cropY;

                        if (imgAspect > displayAspect) {
                            // Image is wider than display - fit height, center width
                            cropH = imgH;
                            cropW = cropH * displayAspect;
                            cropY = 0;
                            cropX = (imgW - cropW) / 2;
                        } else {
                            // Image is taller than display - fit width, center height
                            cropW = imgW;
                            cropH = cropW / displayAspect;
                            cropX = 0;
                            cropY = (imgH - cropH) / 2;
                        }

                        currentCropper.setData({
                            x: cropX,
                            y: cropY,
                            width: cropW,
                            height: cropH
                        });
                    }

                    // Ensure aspect ratio is locked after setting data
                    currentCropper.setAspectRatio(displayAspect);
                }
            });
        }

        function closeCropModal() {
            const modal = document.getElementById('crop-modal');
            modal.classList.remove('active');

            if (currentCropper) {
                currentCropper.destroy();
                currentCropper = null;
            }

            currentCropImage = null;
        }

        function toggleAspectRatio() {
            if (!currentCropper) return;

            const displayAspect = 2560 / 2880;
            const checkbox = document.getElementById('lock-aspect-ratio');

            if (checkbox.checked) {
                // Lock aspect ratio
                currentCropper.setAspectRatio(displayAspect);
            } else {
                // Unlock aspect ratio (free form)
                currentCropper.setAspectRatio(NaN);
            }
        }

        async function saveCrop() {
            if (!currentCropper || !currentCropImage) {
                return;
            }

            // Get crop data
            const cropData = currentCropper.getData();
            const imageData = currentCropper.getImageData();

            // Save crop data (as percentages for responsiveness)
            const cropInfo = {
                x: cropData.x,
                y: cropData.y,
                width: cropData.width,
                height: cropData.height,
                imageWidth: imageData.naturalWidth,
                imageHeight: imageData.naturalHeight
            };

            try {
                // Get current settings
                const settings = await fetch('/api/settings').then(r => r.json());

                // Update image_crops
                if (!settings.image_crops) {
                    settings.image_crops = {};
                }
                settings.image_crops[currentCropImage] = cropInfo;

                // Save settings
                const response = await fetch('/api/settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(settings)
                });

                if (response.ok) {
                    showMessage('Crop saved successfully!', 'success');
                    closeCropModal();
                } else {
                    showMessage('Failed to save crop', 'error');
                }
            } catch (error) {
                console.error('Error saving crop:', error);
                showMessage('Error saving crop', 'error');
            }
        }

        function clearCrop() {
            if (!currentCropper) {
                return;
            }

            // Reset crop in the tool to default display aspect ratio (visual only, no save)
            const displayAspect = 2560 / 2880;
            const imageData = currentCropper.getImageData();
            const imgW = imageData.naturalWidth;
            const imgH = imageData.naturalHeight;
            const imgAspect = imgW / imgH;

            let cropW, cropH, cropX, cropY;

            if (imgAspect > displayAspect) {
                // Image is wider than display - fit height, center width
                cropH = imgH;
                cropW = cropH * displayAspect;
                cropY = 0;
                cropX = (imgW - cropW) / 2;
            } else {
                // Image is taller than display - fit width, center height
                cropW = imgW;
                cropH = cropW / displayAspect;
                cropX = 0;
                cropY = (imgH - cropH) / 2;
            }

            currentCropper.setData({
                x: cropX,
                y: cropY,
                width: cropW,
                height: cropH
            });

            // Ensure aspect ratio is locked
            currentCropper.setAspectRatio(displayAspect);
            const checkbox = document.getElementById('lock-aspect-ratio');
            checkbox.checked = true;

            showMessage('Crop reset to default (not saved)', 'success');
        }

        // Handle "View Kiosk Display" link to sync with current image
        const viewKioskLink = document.getElementById('view-kiosk-link');

        if (viewKioskLink) {
            viewKioskLink.addEventListener('click', function(e) {
                e.preventDefault();

                // Fetch the current image being displayed on the kiosk
                fetch('/api/kiosk/current-image')
                    .then(response => response.json())
                    .then(data => {
                        // Build URL with current image parameter if available
                        let url = '/view';
                        if (data.image_name) {
                            url += '?image=' + encodeURIComponent(data.image_name);
                        }
                        // Navigate to the kiosk view (not blocked by pop-up blockers)
                        window.location.href = url;
                    })
                    .catch(error => {
                        console.error('Error fetching current image:', error);
                        // Fallback: just navigate to /view without parameter
                        window.location.href = '/view';
                    });
            });
        }

        // Handle "Create Atmosphere" button and input
        const showCreateAtmosphereBtn = document.getElementById('show-create-atmosphere-btn');
        const newAtmosphereNameInput = document.getElementById('new-atmosphere-name');

        if (showCreateAtmosphereBtn && newAtmosphereNameInput) {
            // Show input when button is clicked
            showCreateAtmosphereBtn.addEventListener('click', function() {
                showCreateAtmosphereBtn.style.display = 'none';
                newAtmosphereNameInput.style.display = 'block';
                newAtmosphereNameInput.focus();
            });

            // Create atmosphere on Enter key
            newAtmosphereNameInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    createAtmosphere();
                }
            });

            // Hide input on blur if empty
            newAtmosphereNameInput.addEventListener('blur', function() {
                if (!newAtmosphereNameInput.value.trim()) {
                    hideCreateAtmosphereInput();
                }
            });
        }

        // Handle "Create Theme" button and input
        const showCreateThemeBtn = document.getElementById('show-create-theme-btn');
        const newThemeNameInput = document.getElementById('new-theme-name');

        if (showCreateThemeBtn && newThemeNameInput) {
            // Show input when button is clicked
            showCreateThemeBtn.addEventListener('click', function() {
                showCreateThemeBtn.style.display = 'none';
                newThemeNameInput.style.display = 'block';
                newThemeNameInput.focus();
            });

            // Create theme on Enter key
            newThemeNameInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    createTheme();
                }
            });

            // Hide input on blur if empty
            newThemeNameInput.addEventListener('blur', function() {
                if (!newThemeNameInput.value.trim()) {
                    hideCreateThemeInput();
                }
            });
        }

        // Update LED indicators based on current kiosk image or video
        async function updateLEDs() {
            try {
                const response = await fetch('/api/kiosk/current-image');
                if (!response.ok) {
                    console.warn('Failed to fetch current image');
                    return;
                }
                const data = await response.json();
                const currentImage = data.current_image;
                const currentVideoId = data.current_video_id;

                // Update all LED indicators and image card borders
                const allLEDs = document.querySelectorAll('.current-image-led');
                allLEDs.forEach(led => {
                    const card = led.closest('.image-card');
                    // If a video is playing, don't highlight any image
                    if (currentVideoId) {
                        led.classList.remove('active');
                        if (card) card.classList.remove('active');
                    } else if (led.dataset.imageName === currentImage) {
                        led.classList.add('active');
                        if (card) card.classList.add('active');
                    } else {
                        led.classList.remove('active');
                        if (card) card.classList.remove('active');
                    }
                });

                // Update video card highlights
                const videoCards = document.querySelectorAll('.video-card');
                videoCards.forEach(card => {
                    const videoId = card.dataset.videoId;
                    if (videoId === currentVideoId) {
                        card.style.border = '4px solid #2196F3';
                    } else {
                        card.style.border = '1px solid #333';
                    }
                });
            } catch (error) {
                console.error('Error updating LED indicators:', error);
            }
        }

        // Poll for current image every 1 second
        setInterval(updateLEDs, 1000);

        // Track shuffle_id to detect when kiosk reshuffles
        let previousShuffleId = null;

        // Check if shuffle_id has changed (kiosk reshuffled)
        async function checkShuffleIdChanged() {
            try {
                const response = await fetch('/api/settings');
                const settings = await response.json();
                const currentShuffleId = settings.shuffle_id;

                if (previousShuffleId !== null && previousShuffleId !== currentShuffleId) {
                    console.log(`Shuffle ID changed: ${previousShuffleId} -> ${currentShuffleId}. Reloading images...`);
                    await loadImages(); // Reload current images with new order
                }

                previousShuffleId = currentShuffleId;
            } catch (error) {
                console.error('Error checking shuffle_id:', error);
            }
        }

        // WebSocket event handlers for real-time updates
        socket.on('connect', () => {
            console.log('WebSocket connected');
        });

        socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });

        socket.on('reconnect', () => {
            console.log('WebSocket reconnected');
            // Reload page state after reconnection
            initializePage();
        });

        socket.on('settings_update', (settings) => {
            console.log('Settings updated via WebSocket');
            // Check if shuffle_id changed
            if (previousShuffleId !== null && previousShuffleId !== settings.shuffle_id) {
                console.log(`Shuffle ID changed: ${previousShuffleId} -> ${settings.shuffle_id}. Reloading images...`);
                loadImages(); // Reload current images with new order
            }
            previousShuffleId = settings.shuffle_id;

            // Update themes and atmospheres in case they changed
            loadAtmospheres();
            loadThemes();
        });

        socket.on('image_list_changed', () => {
            console.log('Image list changed via WebSocket');
            loadImages();
        });

        socket.on('hour_boundary_changed', (data) => {
            console.log(`Hour boundary changed: period ${data.previous_period} -> ${data.current_period}`);
            loadDayScheduling(); // Reload to update current time period highlighting
        });

        socket.on('thumbnail_generated', (data) => {
            console.log(`Thumbnail generated for video: ${data.video_id}`);
            // Reload the thumbnail image by adding a cache-busting timestamp
            const thumbImg = document.getElementById(`video-thumb-${data.video_id}`);
            if (thumbImg) {
                thumbImg.src = `/thumbnails/${data.video_id}.png?t=${Date.now()}`;
                thumbImg.style.display = 'block';
            }
        });

        socket.on('video_started', (data) => {
            console.log(`Video started: ${data.video_id}`);
            // Update the UI to show Stop button
            currentPlayingVideoId = data.video_id;
            updateVideoButton(data.video_id, true);
        });

        // ====================================================================
        // VIDEO MANAGEMENT (Experimental)
        // ====================================================================

        let currentPlayingVideoId = null;

        async function loadVideos() {
            try {
                const response = await fetch('/api/videos');
                const videos = await response.json();

                const grid = document.getElementById('video-grid');

                if (videos.length === 0) {
                    grid.innerHTML = '<p style="color: #999;">No videos added yet</p>';
                    return;
                }

                grid.innerHTML = '';
                videos.forEach(video => {
                    const card = document.createElement('div');
                    card.className = 'image-card';
                    card.style.cursor = 'pointer';
                    card.id = `video-card-${video.id}`;

                    const isPlaying = currentPlayingVideoId === video.id;

                    card.innerHTML = `
                        <div style="width: 200px; height: 150px; background: #2a2a2a; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden;">
                            <img id="video-thumb-${video.id}"
                                 src="/thumbnails/${video.id}.png"
                                 style="width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0;"
                                 onerror="this.style.display='none'">
                            <div id="video-icon-${video.id}" style="font-size: 48px; position: relative; z-index: 1; text-shadow: 0 0 10px rgba(0,0,0,0.8);">${isPlaying ? '⏹' : '▶'}</div>
                            <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); padding: 4px 8px; font-size: 10px; text-align: center; z-index: 2;">
                                ${(video.tags && video.tags.length > 0) ? video.tags.join(', ') : '<span style="color: #666;">No tags</span>'}
                            </div>
                        </div>
                        <div style="padding: 8px; display: flex; gap: 8px;">
                            <button
                                id="play-btn-${video.id}"
                                onclick="toggleVideo('${video.id}')"
                                style="flex: 1; padding: 6px; background: ${isPlaying ? '#ff9800' : '#4CAF50'}; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                ${isPlaying ? 'Stop' : 'Play'}
                            </button>
                            <button onclick="deleteVideo('${video.id}')" style="padding: 6px 12px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>
                        </div>
                    `;

                    grid.appendChild(card);
                });
            } catch (error) {
                console.error('Error loading videos:', error);
            }
        }

        async function addVideo() {
            const urlInput = document.getElementById('video-url-input');
            const url = urlInput.value.trim();

            if (!url) {
                alert('Please enter a video URL');
                return;
            }

            try {
                const response = await fetch('/api/videos', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });

                if (response.ok) {
                    const video = await response.json();
                    urlInput.value = '';
                    // Reload images to show the new video in the grid
                    await loadImages();

                    // Trigger thumbnail generation (starts video, waits 20s, takes screenshot, leaves video playing)
                    fetch(`/api/videos/${video.id}/generate-thumbnail`, {
                        method: 'POST'
                    }).then(r => r.json()).then(result => {
                        console.log('Thumbnail generation started:', result);
                    }).catch(err => {
                        console.error('Error generating thumbnail:', err);
                    });
                } else {
                    const error = await response.json();
                    alert('Error adding video: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error adding video:', error);
                alert('Error adding video');
            }
        }

        async function toggleVideo(videoId) {
            if (currentPlayingVideoId === videoId) {
                // Stop the currently playing video
                await stopVideo(videoId);
            } else {
                // Play the video
                await playVideo(videoId);
            }
        }

        async function playVideo(videoId) {
            try {
                // Get video data
                const videos = await fetch('/api/videos').then(r => r.json());
                const video = videos.find(v => v.id === videoId);

                if (!video) {
                    alert('Video not found');
                    return;
                }

                // Directly call execute-mpv - backend will show spinner and kill old mpv
                const response = await fetch('/api/videos/execute-mpv', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: video.url,
                        video_id: videoId
                    })
                });

                if (response.ok) {
                    // Update UI to show Stop button for new video
                    const oldVideoId = currentPlayingVideoId;
                    currentPlayingVideoId = videoId;

                    // Update old video button to Play if it exists
                    if (oldVideoId && oldVideoId !== videoId) {
                        updateVideoButton(oldVideoId, false);
                    }

                    // Update new video button to Stop
                    updateVideoButton(videoId, true);
                    console.log('Video playback started');
                } else {
                    const error = await response.json();
                    alert(`Error playing video: ${error.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error playing video:', error);
                alert('Error playing video');
            }
        }

        async function stopVideo(videoId) {
            try {
                const response = await fetch('/api/videos/stop-mpv', {
                    method: 'POST'
                });

                if (response.ok) {
                    // Update UI to show Play button
                    currentPlayingVideoId = null;
                    updateVideoButton(videoId, false);
                    console.log('Video playback stopped');
                } else {
                    alert('Error stopping video');
                }
            } catch (error) {
                console.error('Error stopping video:', error);
                alert('Error stopping video');
            }
        }

        function updateVideoButton(videoId, isPlaying) {
            const button = document.getElementById(`play-btn-${videoId}`);
            const icon = document.getElementById(`video-icon-${videoId}`);

            if (button && icon) {
                button.textContent = isPlaying ? 'Stop' : 'Play';
                button.style.background = isPlaying ? '#ff9800' : '#4CAF50';
                icon.textContent = isPlaying ? '⏹' : '▶';
            }
        }

        async function deleteVideo(videoId) {
            if (!confirm('Delete this video?')) return;

            try {
                // Stop video first if it's currently playing
                if (currentPlayingVideoId === videoId) {
                    await stopVideo(videoId);
                }

                const response = await fetch(`/api/videos/${videoId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    await loadImages(); // Videos appear in image grid
                } else {
                    alert('Error deleting video');
                }
            } catch (error) {
                console.error('Error deleting video:', error);
                alert('Error deleting video');
            }
        }

        async function restorePlaybackStatus() {
            try {
                const response = await fetch('/api/videos/playback-status');
                const status = await response.json();

                if (status.playing && status.video_id) {
                    // Restore the currently playing video ID
                    currentPlayingVideoId = status.video_id;
                    console.log('Restored playback status: video', status.video_id, 'is playing');
                } else {
                    currentPlayingVideoId = null;
                }
            } catch (error) {
                console.error('Error restoring playback status:', error);
                // Don't alert, just fail silently - page will still load
            }
        }

        // Load data on page load
        async function initializePage() {
            await loadDayScheduling();
            await loadAtmospheres();
            await loadThemes();
            await loadImages();
            await restorePlaybackStatus(); // Restore video playback state
            updateLEDs(); // Initialize LED indicators after images are loaded

            // Initialize shuffle_id tracking
            const response = await fetch('/api/settings');
            const settings = await response.json();
            previousShuffleId = settings.shuffle_id;

            // Add event listener for day scheduling toggle
            const dayToggle = document.getElementById('day-scheduling-toggle');
            dayToggle.addEventListener('change', toggleDayScheduling);
        }

        initializePage();
    </script>

    <!-- Crop Modal -->
    <div id="crop-modal" class="crop-modal">
        <div class="crop-modal-content">
            <h2>Crop Image</h2>
            <div style="margin-bottom: 10px;">
                <label style="color: #ffffff; display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="lock-aspect-ratio" checked onchange="toggleAspectRatio()">
                    <span>Lock aspect ratio (2560/2880)</span>
                </label>
            </div>
            <div class="crop-container">
                <img id="crop-image" src="" alt="Image to crop">
            </div>
            <div class="crop-buttons">
                <button class="crop-button tertiary" onclick="closeCropModal()">Cancel</button>
                <button class="crop-button secondary" onclick="clearCrop()">Clear Crop</button>
                <button class="crop-button primary" onclick="saveCrop()">Save Crop</button>
            </div>
        </div>
    </div>

    <!-- Cropper.js Script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
</body>
</html>
