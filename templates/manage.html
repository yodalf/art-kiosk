<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiosk Image Management</title>

    <!-- Cropper.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000000;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #1a1a1a;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(255, 255, 255, 0.1);
            padding: 30px;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #aaaaaa;
            margin-bottom: 30px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #333333;
            padding-bottom: 10px;
        }

        .settings-form {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .settings-form label {
            font-weight: 500;
            color: #cccccc;
        }

        .settings-form input[type="number"] {
            padding: 8px 12px;
            border: 1px solid #444444;
            border-radius: 4px;
            font-size: 14px;
            width: 100px;
            background: #2a2a2a;
            color: #ffffff;
        }

        .settings-form input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .settings-form button {
            background: #2196F3;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .settings-form button:hover {
            background: #1976D2;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .image-card {
            border: 1px solid #333333;
            border-radius: 8px;
            overflow: visible;
            background: #2a2a2a;
            transition: transform 0.2s, box-shadow 0.2s, border 0.2s;
            position: relative;
        }

        .image-card.active {
            border: 3px solid #FF9800;
        }

        /* Keep image area clipped to rounded corners */
        .image-card > img,
        .image-card > div[style*="overflow: hidden"] {
            border-radius: 8px 8px 0 0;
            overflow: hidden;
        }

        .image-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .image-card.disabled {
            border: 1px solid #444444;
        }

        .image-card.disabled img {
            filter: grayscale(100%);
            opacity: 0.5;
        }

        .image-card.disabled .card-info,
        .image-card.disabled .image-tags {
            opacity: 0.5;
        }

        .image-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            background: #1a1a1a;
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
        }

        .image-card img:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }

        /* Hover effect for crop containers */
        .image-card > div[style*="overflow: hidden"]:hover img {
            filter: brightness(1.1);
        }

        /* Blue LED indicator for currently displayed image */
        .current-image-led {
            position: absolute;
            bottom: 8px;
            right: 8px;
            width: 12px;
            height: 12px;
            background: #2196F3;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.8), 0 0 16px rgba(33, 150, 243, 0.4);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .current-image-led.active {
            opacity: 1;
        }

        .image-checkbox-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(26, 26, 26, 0.9);
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 10;
        }

        .image-checkbox-container label {
            font-size: 12px;
            font-weight: 500;
            color: #ffffff;
            cursor: pointer;
            margin: 0;
        }

        .image-checkbox-container input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .image-card-info {
            padding: 12px;
        }

        .image-card-name {
            font-size: 14px;
            color: #ffffff;
            margin-bottom: 8px;
            word-break: break-all;
        }

        .image-card-size {
            font-size: 12px;
            color: #888888;
            margin-bottom: 12px;
        }

        .delete-button {
            background: #f44336;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }

        .delete-button:hover {
            background: #d32f2f;
        }

        .message {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }

        .message.success {
            background: #1b5e20;
            color: #a5d6a7;
            border: 1px solid #4caf50;
        }

        .message.error {
            background: #b71c1c;
            color: #ef9a9a;
            border: 1px solid #f44336;
        }

        .message.visible {
            display: block;
        }

        .links {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .links a {
            color: #64b5f6;
            text-decoration: none;
            font-weight: 500;
        }

        .links a:hover {
            text-decoration: underline;
        }


        .remote-control {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #ff9800;
            margin-bottom: 20px;
        }

        .remote-control h3 {
            color: #ffb74d;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .control-button {
            background: #ff9800;
            color: white;
            padding: 12px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .control-button:hover {
            background: #f57c00;
        }

        .control-button:active {
            transform: scale(0.95);
        }

        .control-button.danger {
            background: #f44336;
        }

        .control-button.danger:hover {
            background: #d32f2f;
        }

        .control-button.success {
            background: #4CAF50;
        }

        .control-button.success:hover {
            background: #45a049;
        }

        .control-button-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .led-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
            transition: background 0.3s;
        }

        .led-indicator.active {
            background: #2196F3;
            box-shadow: 0 0 8px #2196F3;
        }

        .debug-toggle-button {
            background: #9e9e9e;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.3s;
        }

        .debug-toggle-button:hover {
            background: #757575;
        }

        .debug-toggle-button.active {
            background: #4CAF50;
        }

        .debug-toggle-button.active:hover {
            background: #45a049;
        }

        .debug-panel {
            background: #2a2a2a;
            border: 2px solid #444444;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .debug-panel h3 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .debug-console {
            background: #263238;
            color: #aed581;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 15px;
            border-radius: 4px;
            height: 1000px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .debug-console-line {
            margin-bottom: 4px;
            word-wrap: break-word;
        }

        .debug-console-line.error {
            color: #ef5350;
        }

        .debug-console-line.info {
            color: #81c784;
        }

        .debug-timestamp {
            color: #78909c;
            margin-right: 8px;
        }

        .debug-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .debug-button {
            background: #757575;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .debug-button:hover {
            background: #616161;
        }

        .debug-panel.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .theme-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #1e3a5f;
            border: 1px solid #2196F3;
            border-radius: 4px;
            font-size: 14px;
            color: #64b5f6;
        }

        .theme-badge.active {
            background: #2196F3;
            color: white;
            border: 3px solid #FF9800;
        }

        .theme-badge .theme-name {
            cursor: pointer;
            font-weight: 500;
        }

        .theme-badge .theme-name:hover {
            text-decoration: underline;
        }

        .theme-badge button {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 12px;
        }

        .theme-badge button:hover {
            background: #d32f2f;
        }

        .image-themes {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .image-theme-tag {
            display: inline-block;
            padding: 3px 8px;
            background: #e3f2fd;
            color: #1565c0;
            border-radius: 3px;
            font-size: 11px;
        }

        .theme-selector {
            margin-top: 8px;
        }

        .theme-selector select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
            width: 100%;
        }

        /* Crop Modal */
        .crop-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .crop-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .crop-modal-content {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .crop-container {
            max-width: 800px;
            max-height: 600px;
            margin: 20px 0;
        }

        .crop-container img {
            max-width: 100%;
        }

        .crop-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 15px;
        }

        .crop-button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .crop-button.primary {
            background: #4CAF50;
            color: white;
        }

        .crop-button.primary:hover {
            background: #45a049;
        }

        .crop-button.secondary {
            background: #f44336;
            color: white;
        }

        .crop-button.secondary:hover {
            background: #da190b;
        }

        .crop-button.tertiary {
            background: #757575;
            color: white;
        }

        .crop-button.tertiary:hover {
            background: #616161;
        }

        .crop-image-button {
            background: #2196F3;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 8px;
        }

        /* Action menu styles */
        .action-menu-container {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 10;
        }

        .action-menu-button {
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid #444444;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            color: #ffffff;
            transition: background 0.2s;
        }

        .action-menu-button:hover {
            background: #2a2a2a;
            color: #ffffff;
        }

        .action-menu-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            margin-bottom: 4px;
            background: #2a2a2a;
            border: 1px solid #444444;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            min-width: 180px;
            z-index: 1000;
            display: none;
        }

        .action-menu-dropdown.show {
            display: block;
        }

        .menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #ffffff;
            transition: background 0.2s;
            position: relative;
        }

        .menu-item:hover {
            background: #3a3a3a;
        }

        .menu-item:first-child {
            border-radius: 4px 4px 0 0;
        }

        .menu-item:last-child {
            border-radius: 0 0 4px 4px;
        }

        .menu-item-danger {
            color: #f44336;
        }

        .menu-item-danger:hover {
            background: #ffebee;
        }

        .menu-item.has-submenu {
            padding-right: 32px;
        }

        .submenu-arrow {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #999;
        }

        .submenu {
            position: absolute;
            left: 100%;
            bottom: 0;
            margin-left: 4px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            min-width: 150px;
            display: none;
            z-index: 1001;
        }

        .submenu.show {
            display: block;
        }

        .submenu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            color: #333;
            transition: background 0.2s;
        }

        .submenu-item:hover {
            background: #f5f5f5;
        }

        .submenu-item:first-child {
            border-radius: 4px 4px 0 0;
        }

        .submenu-item:last-child {
            border-radius: 0 0 4px 4px;
        }

        .crop-image-button:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Kiosk Image Management</h1>

        <div class="links">
            <a href="/view" id="view-kiosk-link">View Kiosk Display</a>
        </div>

        <div id="message" class="message"></div>

        <div class="remote-control">
            <h3>üéÆ Remote Control - Control the Kiosk Display</h3>
            <div class="control-buttons">
                <div class="control-button-wrapper">
                    <button class="control-button success" onclick="sendCommand('play')">‚ñ∂Ô∏è Play</button>
                    <div class="led-indicator" id="led-play"></div>
                </div>
                <div class="control-button-wrapper">
                    <button class="control-button danger" onclick="sendCommand('pause')">‚è∏Ô∏è Pause</button>
                    <div class="led-indicator" id="led-pause"></div>
                </div>
                <div class="control-button-wrapper">
                    <button class="control-button" onclick="sendCommand('reload')">üîÉ Reload</button>
                    <div class="led-indicator" id="led-reload"></div>
                </div>
                <div class="control-button-wrapper">
                    <button class="control-button" onclick="sendCommand('prev')">‚¨ÖÔ∏è Previous</button>
                    <div class="led-indicator" id="led-prev"></div>
                </div>
                <div class="control-button-wrapper">
                    <button class="control-button" onclick="sendCommand('next')">‚û°Ô∏è Next</button>
                    <div class="led-indicator" id="led-next"></div>
                </div>
            </div>
        </div>

        <div class="section">
            <div style="border-bottom: 2px solid #333333; margin-bottom: 15px;"></div>

            <h3 style="margin-bottom: 15px; color: #ffffff;">Atmospheres</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 20px; align-items: center;">
                <button id="show-create-atmosphere-btn" style="background: #9C27B0; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">New Atmosphere</button>
                <input type="text" id="new-atmosphere-name" placeholder="Atmosphere name" style="padding: 8px 12px; border: 1px solid #444444; border-radius: 4px; flex: 1; display: none; background: #2a2a2a; color: #ffffff;">
            </div>

            <div id="atmospheres-list" style="display: flex; flex-wrap: wrap; gap: 10px;">
                <!-- Atmospheres will be loaded here -->
            </div>

            <div style="margin-bottom: 30px;"></div>

            <h3 style="margin-bottom: 15px; color: #ffffff;">Themes</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 20px; align-items: center;">
                <a href="/upload" target="_blank" style="display: inline-block; background: #4CAF50; color: white; padding: 8px 16px; border-radius: 4px; text-decoration: none; font-size: 14px;">File Upload</a>
                <button id="show-create-theme-btn" style="background: #4CAF50; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">New Theme</button>
                <input type="text" id="new-theme-name" placeholder="Theme name" style="padding: 8px 12px; border: 1px solid #444444; border-radius: 4px; flex: 1; display: none; background: #2a2a2a; color: #ffffff;">
            </div>

            <div id="themes-list" style="display: flex; flex-wrap: wrap; gap: 10px;">
                <!-- Themes will be loaded here -->
            </div>
        </div>

        <div class="section">
            <h2 id="current-images-heading">Current Images</h2>
            <div class="image-grid" id="image-grid">
                <p style="color: #999;">Loading images...</p>
            </div>
        </div>

        <div style="margin-bottom: 20px;">
            <button class="debug-toggle-button" onclick="toggleDebugPanel()">üêõ DEBUG</button>
        </div>

        <div class="debug-panel" id="debug-panel" style="display: none;">
            <h3>üêõ Debug Console - Kiosk Display Logs</h3>
            <div class="debug-console" id="debug-console">
                <div class="debug-console-line">Loading debug messages...</div>
            </div>
            <div class="debug-controls">
                <button class="debug-button" onclick="clearDebugConsole()">Clear Console</button>
                <button class="debug-button" onclick="clipDebugConsole()">üìã Clip</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // Initialize Socket.IO connection
        const socket = io();

        // Menu handling functions (define early for use in createImageCard)
        function toggleMenu(menuContainer) {
            const dropdown = menuContainer.querySelector('.action-menu-dropdown');
            const isOpen = dropdown.classList.contains('show');

            // Close all other menus first
            closeAllMenus();

            // Toggle this menu
            if (!isOpen) {
                dropdown.classList.add('show');
                // Raise the parent card's z-index so dropdown and submenu appear above other cards
                const card = menuContainer.closest('.image-card');
                if (card) {
                    card.style.zIndex = '1002';
                }
            }
        }

        function closeAllMenus() {
            document.querySelectorAll('.action-menu-dropdown.show').forEach(dropdown => {
                dropdown.classList.remove('show');
                // Reset the parent card's z-index
                const card = dropdown.closest('.image-card');
                if (card) {
                    card.style.zIndex = '';
                }
            });
        }

        // Close menus when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.action-menu-container')) {
                closeAllMenus();
            }
        });

        // Debug console state
        let debugEnabled = false;
        let debugPollInterval = null;
        let debugPanelVisible = false;

        // Toggle debug panel visibility
        function toggleDebugPanel() {
            const panel = document.getElementById('debug-panel');
            const button = document.querySelector('.debug-toggle-button');
            debugPanelVisible = !debugPanelVisible;

            if (debugPanelVisible) {
                panel.style.display = 'block';
                button.classList.add('active');
                // Automatically enable debugging and load messages when panel opens
                debugEnabled = true;
                refreshDebugConsole();
            } else {
                panel.style.display = 'none';
                button.classList.remove('active');
                // Disable debugging when panel closes
                debugEnabled = false;
            }
        }

        // Refresh debug console with latest messages
        async function refreshDebugConsole() {
            if (!debugEnabled) return;

            try {
                const response = await fetch('/api/debug/messages');
                const messages = await response.json();

                const console = document.getElementById('debug-console');
                console.innerHTML = '';

                if (messages.length === 0) {
                    console.innerHTML = '<div class="debug-console-line">No debug messages yet. Waiting for kiosk activity...</div>';
                    return;
                }

                messages.forEach(msg => {
                    const line = document.createElement('div');
                    line.className = `debug-console-line ${msg.level}`;

                    const timestamp = new Date(msg.timestamp * 1000).toLocaleTimeString();
                    const timestampSpan = document.createElement('span');
                    timestampSpan.className = 'debug-timestamp';
                    timestampSpan.textContent = `[${timestamp}]`;

                    line.appendChild(timestampSpan);
                    line.appendChild(document.createTextNode(msg.message));

                    console.appendChild(line);
                });

                // Auto-scroll to bottom
                console.scrollTop = console.scrollHeight;
            } catch (error) {
                console.error('Error fetching debug messages:', error);
            }
        }

        // Clear debug console
        async function clearDebugConsole() {
            try {
                await fetch('/api/debug/clear', { method: 'POST' });
                const console = document.getElementById('debug-console');
                console.innerHTML = '<div class="debug-console-line">Console cleared.</div>';
            } catch (error) {
                console.error('Error clearing debug console:', error);
            }
        }

        // Copy debug console to clipboard
        async function clipDebugConsole() {
            const button = event.target;

            try {
                const consoleEl = document.getElementById('debug-console');
                const lines = consoleEl.querySelectorAll('.debug-console-line');

                // Extract text from all lines
                const text = Array.from(lines).map(line => line.textContent).join('\n');

                // Try modern clipboard API first, fallback to textarea method
                let success = false;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    try {
                        await navigator.clipboard.writeText(text);
                        success = true;
                    } catch (e) {
                        // Clipboard API failed, use fallback
                        console.log('Clipboard API failed, using fallback');
                    }
                }

                // Fallback method using textarea (works on HTTP)
                if (!success) {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    success = true;
                }

                // Visual feedback - change button appearance
                button.style.background = '#4CAF50';
                button.textContent = '‚úì Copied!';

                setTimeout(() => {
                    button.style.background = '';
                    button.textContent = 'üìã Clip';
                }, 1500);

                // Show feedback message
                showMessage('Debug log copied to clipboard', 'success');
            } catch (error) {
                console.error('Error copying to clipboard:', error);

                // Visual feedback for error
                button.style.background = '#f44336';
                button.textContent = '‚úó Failed';

                setTimeout(() => {
                    button.style.background = '';
                    button.textContent = 'üìã Clip';
                }, 1500);

                showMessage('Failed to copy to clipboard: ' + error.message, 'error');
            }
        }

        // Append a single debug message to the console
        function appendDebugMessage(msg) {
            if (!debugEnabled) return;

            const consoleEl = document.getElementById('debug-console');

            // Clear placeholder text if this is the first message
            if (consoleEl.textContent.includes('No debug messages yet')) {
                consoleEl.innerHTML = '';
            }

            const line = document.createElement('div');
            line.className = `debug-console-line ${msg.level}`;

            const timestamp = new Date(msg.timestamp * 1000).toLocaleTimeString();
            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'debug-timestamp';
            timestampSpan.textContent = `[${timestamp}]`;

            line.appendChild(timestampSpan);
            line.appendChild(document.createTextNode(msg.message));

            consoleEl.appendChild(line);

            // Auto-scroll to bottom
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        // Track current playback state
        let isPlaying = true; // Assume playing by default

        // Update LED indicators
        function updateLEDs() {
            // Update play/pause LEDs
            if (isPlaying) {
                document.getElementById('led-play').classList.add('active');
                document.getElementById('led-pause').classList.remove('active');
            } else {
                document.getElementById('led-play').classList.remove('active');
                document.getElementById('led-pause').classList.add('active');
            }
        }

        // Flash LED briefly for action buttons
        function flashLED(ledId) {
            const led = document.getElementById(ledId);
            led.classList.add('active');
            setTimeout(() => {
                led.classList.remove('active');
            }, 500);
        }

        // Send remote control command
        function sendCommand(command) {
            try {
                // Send command via WebSocket
                socket.emit('send_command', { command });

                // Update LED indicators based on command
                switch(command) {
                    case 'play':
                        isPlaying = true;
                        updateLEDs();
                        break;
                    case 'pause':
                        isPlaying = false;
                        updateLEDs();
                        break;
                    case 'prev':
                        flashLED('led-prev');
                        break;
                    case 'next':
                        flashLED('led-next');
                        break;
                    case 'reload':
                        isPlaying = true; // Reload resumes playback
                        updateLEDs();
                        flashLED('led-reload');
                        break;
                }
            } catch (error) {
                console.error('Error sending command:', error);
                showMessage('Error sending command', 'error');
            }
        }

        // Jump to specific image in kiosk display
        function jumpToImage(imageName) {
            try {
                // Send jump command via WebSocket
                socket.emit('send_command', { command: 'jump', image_name: imageName });
                // Success - no message shown
            } catch (error) {
                console.error('Error jumping to image:', error);
                showMessage('Error jumping to image', 'error');
            }
        }

        // Load and display images
        async function loadImages() {
            try {
                const response = await fetch('/api/images?enabled_only=true');
                const images = await response.json();

                // Load crop settings
                const settingsResponse = await fetch('/api/settings');
                const settings = await settingsResponse.json();
                const imageCrops = settings.image_crops || {};

                const grid = document.getElementById('image-grid');
                const heading = document.getElementById('current-images-heading');
                grid.innerHTML = '';

                // Update heading based on active atmosphere or theme
                if (activeAtmosphere) {
                    heading.textContent = `Current Images - Atmosphere: ${activeAtmosphere}`;
                } else if (activeTheme && activeTheme !== 'All Images') {
                    heading.textContent = `Current Images - Theme: ${activeTheme}`;
                } else {
                    heading.textContent = activeTheme === 'All Images' ? 'Current Images - All Images' : 'Current Images';
                }

                if (images.length === 0) {
                    grid.innerHTML = '<p style="color: #999;">No enabled images in current selection</p>';
                    return;
                }

                // Images are already filtered and shuffled by backend
                images.forEach(image => {
                    const cropData = imageCrops[image.name];
                    const card = createImageCard(image, cropData);
                    grid.appendChild(card);
                });
            } catch (error) {
                console.error('Error loading images:', error);
                showMessage('Error loading images', 'error');
            }
        }

        // Apply crop to thumbnail image
        function applyCropToThumbnail(img, container, cropData) {
            const containerW = container.clientWidth;
            const containerH = container.clientHeight; // 200px

            const cropX = cropData.x;
            const cropY = cropData.y;
            const cropW = cropData.width;
            const cropH = cropData.height;
            const imgW = cropData.imageWidth;
            const imgH = cropData.imageHeight;

            // Calculate scale to make crop region fill container (cover behavior)
            const scaleX = containerW / cropW;
            const scaleY = containerH / cropH;
            const scale = Math.max(scaleX, scaleY);

            // Calculate scaled image dimensions
            const scaledImgW = imgW * scale;
            const scaledImgH = imgH * scale;

            // Calculate scaled crop dimensions
            const scaledCropW = cropW * scale;
            const scaledCropH = cropH * scale;

            // Calculate position to place crop region
            const offsetX = -cropX * scale;
            const offsetY = -cropY * scale;

            // Center the crop region in container
            const centerX = (containerW - scaledCropW) / 2;
            const centerY = (containerH - scaledCropH) / 2;

            // Apply styles
            img.style.position = 'absolute';
            img.style.width = `${scaledImgW}px`;
            img.style.height = `${scaledImgH}px`;
            img.style.left = `${offsetX + centerX}px`;
            img.style.top = `${offsetY + centerY}px`;
            img.style.objectFit = 'fill';
            img.style.maxWidth = 'none';
            img.style.maxHeight = 'none';
        }

        // Create image card element
        function createImageCard(image, cropData) {
            const card = document.createElement('div');
            card.className = 'image-card';
            if (!image.enabled) {
                card.classList.add('disabled');
            }

            // If crop exists, create a container for the cropped image
            if (cropData) {
                const cropContainer = document.createElement('div');
                cropContainer.style.width = '100%';
                cropContainer.style.height = '200px';
                cropContainer.style.overflow = 'hidden';
                cropContainer.style.position = 'relative';
                cropContainer.style.background = '#f0f0f0';
                cropContainer.style.cursor = 'pointer';
                cropContainer.onclick = () => jumpToImage(image.name);
                cropContainer.title = 'Click to jump to this image in the kiosk display';

                const img = document.createElement('img');
                img.src = image.url;
                img.alt = image.name;
                img.style.cursor = 'pointer';

                // Apply crop when image loads
                img.onload = () => applyCropToThumbnail(img, cropContainer, cropData);

                cropContainer.appendChild(img);
                card.appendChild(cropContainer);
            } else {
                // No crop - show normal image
                const img = document.createElement('img');
                img.src = image.url;
                img.alt = image.name;
                img.style.cursor = 'pointer';
                img.onclick = () => jumpToImage(image.name);
                img.title = 'Click to jump to this image in the kiosk display';
                card.appendChild(img);
            }

            // Create checkbox container
            const checkboxContainer = document.createElement('div');
            checkboxContainer.className = 'image-checkbox-container';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = image.enabled;
            checkbox.id = `enable-${image.name}`;
            checkbox.onchange = () => toggleImageEnabled(image.name, checkbox.checked, card);

            const label = document.createElement('label');
            label.htmlFor = `enable-${image.name}`;
            label.textContent = 'Show';

            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(label);

            const info = document.createElement('div');
            info.className = 'image-card-info';

            // Theme tags
            const themesDiv = document.createElement('div');
            themesDiv.className = 'image-themes';
            (image.themes || []).forEach(themeName => {
                const tag = document.createElement('span');
                tag.className = 'image-theme-tag';
                tag.style.cursor = 'pointer';
                tag.title = 'Click to remove from theme';
                tag.textContent = themeName + ' ‚úï';
                tag.onclick = async () => {
                    const newThemes = (image.themes || []).filter(t => t !== themeName);
                    await updateImageThemes(image.name, newThemes);
                    await loadImages();
                };
                themesDiv.appendChild(tag);
            });

            // Action menu (three dots)
            const menuContainer = document.createElement('div');
            menuContainer.className = 'action-menu-container';

            const menuButton = document.createElement('button');
            menuButton.className = 'action-menu-button';
            menuButton.innerHTML = '‚ãÆ';
            menuButton.title = 'Actions';
            menuButton.onclick = (e) => {
                e.stopPropagation();
                toggleMenu(menuContainer);
            };

            const menuDropdown = document.createElement('div');
            menuDropdown.className = 'action-menu-dropdown';

            // Add to theme submenu
            if (Object.keys(availableThemes).length > 0) {
                const themeMenuItem = document.createElement('div');
                themeMenuItem.className = 'menu-item has-submenu';
                themeMenuItem.innerHTML = 'Add to theme <span class="submenu-arrow">‚ñ∏</span>';

                const themeSubmenu = document.createElement('div');
                themeSubmenu.className = 'submenu';

                for (const themeName in availableThemes) {
                    if (!(image.themes || []).includes(themeName)) {
                        const themeOption = document.createElement('div');
                        themeOption.className = 'submenu-item';
                        themeOption.textContent = themeName;
                        themeOption.onclick = async (e) => {
                            e.stopPropagation();
                            const newThemes = [...(image.themes || []), themeName];
                            await updateImageThemes(image.name, newThemes);
                            await loadImages();
                        };
                        themeSubmenu.appendChild(themeOption);
                    }
                }

                themeMenuItem.appendChild(themeSubmenu);

                // Handle submenu hover interaction
                themeMenuItem.addEventListener('mouseenter', () => {
                    themeSubmenu.classList.add('show');
                });

                themeMenuItem.addEventListener('mouseleave', (e) => {
                    // Delay hiding to allow mouse movement to submenu
                    setTimeout(() => {
                        if (!themeSubmenu.matches(':hover')) {
                            themeSubmenu.classList.remove('show');
                        }
                    }, 100);
                });

                themeSubmenu.addEventListener('mouseleave', () => {
                    themeSubmenu.classList.remove('show');
                });

                menuDropdown.appendChild(themeMenuItem);
            }

            // Crop menu item
            const cropMenuItem = document.createElement('div');
            cropMenuItem.className = 'menu-item';
            cropMenuItem.textContent = 'Crop';
            cropMenuItem.onclick = (e) => {
                e.stopPropagation();
                closeAllMenus();
                openCropModal(image.name, image.url);
            };
            menuDropdown.appendChild(cropMenuItem);

            // Delete menu item
            const deleteMenuItem = document.createElement('div');
            deleteMenuItem.className = 'menu-item menu-item-danger';
            deleteMenuItem.textContent = 'Delete';
            deleteMenuItem.onclick = (e) => {
                e.stopPropagation();
                closeAllMenus();
                deleteImage(image.name);
            };
            menuDropdown.appendChild(deleteMenuItem);

            menuContainer.appendChild(menuButton);
            menuContainer.appendChild(menuDropdown);

            info.appendChild(themesDiv);

            card.appendChild(menuContainer);
            card.appendChild(checkboxContainer);
            // Image or crop container already appended above
            card.appendChild(info);

            // Add blue LED indicator for current image
            const led = document.createElement('div');
            led.className = 'current-image-led';
            led.dataset.imageName = image.name;
            card.appendChild(led);

            return card;
        }

        // Delete image
        async function deleteImage(filename) {
            if (!confirm(`Delete ${filename}?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/images/${encodeURIComponent(filename)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    showMessage('Image deleted successfully', 'success');
                    loadImages();
                } else {
                    showMessage('Error deleting image', 'error');
                }
            } catch (error) {
                console.error('Error deleting image:', error);
                showMessage('Error deleting image', 'error');
            }
        }

        // Toggle image enabled state
        async function toggleImageEnabled(filename, enabled, cardElement) {
            try {
                const response = await fetch(`/api/images/${encodeURIComponent(filename)}/toggle`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled })
                });

                if (response.ok) {
                    // Update visual state immediately
                    if (enabled) {
                        cardElement.classList.remove('disabled');
                    } else {
                        cardElement.classList.add('disabled');
                    }
                } else {
                    showMessage('Error updating image state', 'error');
                }
            } catch (error) {
                console.error('Error toggling image:', error);
                showMessage('Error updating image state', 'error');
            }
        }

        // Show message
        function showMessage(text, type) {
            const message = document.getElementById('message');
            message.textContent = text;
            message.className = `message ${type} visible`;

            setTimeout(() => {
                message.classList.remove('visible');
            }, 3000);
        }

        // Atmosphere management functions
        let availableAtmospheres = {};
        let activeAtmosphere = null;
        let atmosphereThemes = {};

        async function loadAtmospheres() {
            try {
                const response = await fetch('/api/atmospheres');
                const data = await response.json();
                availableAtmospheres = data.atmospheres;
                activeAtmosphere = data.active_atmosphere;
                atmosphereThemes = data.atmosphere_themes;

                // Update atmospheres list
                const atmospheresList = document.getElementById('atmospheres-list');
                atmospheresList.innerHTML = '';

                for (const atmosphereName in availableAtmospheres) {
                    const atmosphere = availableAtmospheres[atmosphereName];
                    const intervalMinutes = (atmosphere.interval || 3600) / 60;
                    const themesInAtmosphere = atmosphereThemes[atmosphereName] || [];

                    const badge = document.createElement('div');
                    badge.className = 'theme-badge';
                    if (atmosphereName === activeAtmosphere) {
                        badge.classList.add('active');
                    }

                    badge.innerHTML = `
                        <span class="theme-name" data-atmosphere="${atmosphereName}">${atmosphereName}</span>
                        <div style="font-size: 11px; color: #666; margin-top: 3px;">${themesInAtmosphere.length} theme(s)</div>
                        <div style="display: flex; align-items: center; gap: 5px; margin-top: 5px;">
                            <button class="interval-display-btn" data-atmosphere="${atmosphereName}" style="padding: 6px 12px; font-size: 12px; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-family: inherit;">
                                ${intervalMinutes} min
                            </button>
                            <input type="number" class="interval-input" data-atmosphere="${atmosphereName}" value="${intervalMinutes}" min="1" max="1440" step="0.5" style="width: 80px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; display: none;">
                            <button onclick="editAtmosphereThemes('${atmosphereName}')" style="padding: 6px 12px; font-size: 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-weight: 500;">Themes</button>
                            <button onclick="deleteAtmosphere('${atmosphereName}')" style="padding: 6px 12px; font-size: 12px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: inherit;">Delete</button>
                        </div>
                    `;

                    // Add click handler for atmosphere name to activate atmosphere
                    const atmosphereNameSpan = badge.querySelector('.theme-name');
                    atmosphereNameSpan.addEventListener('click', () => {
                        setActiveAtmosphere(atmosphereName);
                    });

                    // Add click handler for interval button
                    const intervalBtn = badge.querySelector('.interval-display-btn');
                    const intervalInput = badge.querySelector('.interval-input');

                    intervalBtn.addEventListener('click', () => {
                        intervalBtn.style.display = 'none';
                        intervalInput.style.display = 'block';
                        intervalInput.focus();
                        intervalInput.select();
                    });

                    // Save on blur or enter key
                    intervalInput.addEventListener('blur', () => {
                        saveAtmosphereIntervalFromInput(atmosphereName, intervalInput, intervalBtn);
                    });

                    intervalInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            intervalInput.blur();
                        }
                    });

                    atmospheresList.appendChild(badge);
                }
            } catch (error) {
                console.error('Error loading atmospheres:', error);
            }
        }

        async function createAtmosphere() {
            const nameInput = document.getElementById('new-atmosphere-name');
            const createBtn = document.getElementById('show-create-atmosphere-btn');
            const name = nameInput.value.trim();

            if (!name) {
                showMessage('Please enter an atmosphere name', 'error');
                return;
            }

            try {
                const response = await fetch('/api/atmospheres', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                if (response.ok) {
                    nameInput.value = '';
                    nameInput.style.display = 'none';
                    createBtn.style.display = 'block';
                    await loadAtmospheres();
                    showMessage(`Atmosphere "${name}" created`, 'success');
                } else {
                    const error = await response.json();
                    showMessage(error.error || 'Error creating atmosphere', 'error');
                }
            } catch (error) {
                console.error('Error creating atmosphere:', error);
                showMessage('Error creating atmosphere', 'error');
            }
        }

        function hideCreateAtmosphereInput() {
            const nameInput = document.getElementById('new-atmosphere-name');
            const createBtn = document.getElementById('show-create-atmosphere-btn');
            nameInput.value = '';
            nameInput.style.display = 'none';
            createBtn.style.display = 'block';
        }

        async function saveAtmosphereIntervalFromInput(atmosphereName, inputElement, btnElement) {
            const intervalMinutes = parseFloat(inputElement.value);

            if (!intervalMinutes || intervalMinutes < 1) {
                showMessage('Invalid interval value', 'error');
                inputElement.style.display = 'none';
                btnElement.style.display = 'block';
                return;
            }

            const intervalSeconds = Math.round(intervalMinutes * 60);

            try {
                const response = await fetch(`/api/atmospheres/${encodeURIComponent(atmosphereName)}/interval`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval: intervalSeconds })
                });

                if (response.ok) {
                    availableAtmospheres[atmosphereName].interval = intervalSeconds;
                    btnElement.textContent = `${intervalMinutes} min`;
                    inputElement.style.display = 'none';
                    btnElement.style.display = 'block';
                    showMessage(`Interval updated for atmosphere "${atmosphereName}"`, 'success');
                } else {
                    showMessage('Error updating atmosphere interval', 'error');
                    inputElement.style.display = 'none';
                    btnElement.style.display = 'block';
                }
            } catch (error) {
                console.error('Error updating atmosphere interval:', error);
                showMessage('Error updating atmosphere interval', 'error');
                inputElement.style.display = 'none';
                btnElement.style.display = 'block';
            }
        }

        async function setActiveAtmosphere(atmosphereName) {
            try {
                const response = await fetch('/api/atmospheres/active', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ atmosphere_name: atmosphereName })
                });

                if (response.ok) {
                    activeAtmosphere = atmosphereName;

                    // Reload both atmospheres and themes to update active state
                    // Note: Theme badges won't show as active when an atmosphere is active
                    await loadAtmospheres();
                    await loadThemes();
                    await loadImages();
                } else {
                    showMessage('Error setting active atmosphere', 'error');
                }
            } catch (error) {
                console.error('Error setting active atmosphere:', error);
                showMessage('Error setting active atmosphere', 'error');
            }
        }

        async function deleteAtmosphere(atmosphereName) {
            if (!confirm(`Delete atmosphere "${atmosphereName}"?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/atmospheres/${encodeURIComponent(atmosphereName)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    await loadAtmospheres();
                    await loadImages();
                    showMessage(`Atmosphere "${atmosphereName}" deleted`, 'success');
                } else {
                    showMessage('Error deleting atmosphere', 'error');
                }
            } catch (error) {
                console.error('Error deleting atmosphere:', error);
                showMessage('Error deleting atmosphere', 'error');
            }
        }

        function editAtmosphereThemes(atmosphereName) {
            const themesInAtmosphere = atmosphereThemes[atmosphereName] || [];

            // Build checkboxes for all themes
            let themeCheckboxes = '';
            for (const themeName in availableThemes) {
                const checked = themesInAtmosphere.includes(themeName) ? 'checked' : '';
                themeCheckboxes += `
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" value="${themeName}" ${checked} style="cursor: pointer;">
                            <span>${themeName}</span>
                        </label>
                    </div>
                `;
            }

            const html = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;" id="atmosphere-themes-modal">
                    <div style="background: white; padding: 30px; border-radius: 8px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
                        <h3 style="margin-top: 0; margin-bottom: 20px;">Select Themes for "${atmosphereName}"</h3>
                        <div id="theme-checkboxes">
                            ${themeCheckboxes}
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="saveAtmosphereThemes('${atmosphereName}')" style="flex: 1; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Save</button>
                            <button onclick="closeAtmosphereThemesModal()" style="flex: 1; padding: 10px; background: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', html);
        }

        async function saveAtmosphereThemes(atmosphereName) {
            const checkboxes = document.querySelectorAll('#theme-checkboxes input[type="checkbox"]:checked');
            const selectedThemes = Array.from(checkboxes).map(cb => cb.value);

            try {
                const response = await fetch(`/api/atmospheres/${encodeURIComponent(atmosphereName)}/themes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ themes: selectedThemes })
                });

                if (response.ok) {
                    atmosphereThemes[atmosphereName] = selectedThemes;
                    closeAtmosphereThemesModal();
                    await loadAtmospheres();
                    await loadImages();
                    showMessage(`Themes updated for atmosphere "${atmosphereName}"`, 'success');
                } else {
                    showMessage('Error updating atmosphere themes', 'error');
                }
            } catch (error) {
                console.error('Error updating atmosphere themes:', error);
                showMessage('Error updating atmosphere themes', 'error');
            }
        }

        function closeAtmosphereThemesModal() {
            const modal = document.getElementById('atmosphere-themes-modal');
            if (modal) {
                modal.remove();
            }
        }

        // Theme management functions
        let availableThemes = {};
        let activeTheme = null;

        async function loadThemes() {
            try {
                const response = await fetch('/api/themes');
                const data = await response.json();
                availableThemes = data.themes;
                activeTheme = data.active_theme;

                // Update themes list
                const themesList = document.getElementById('themes-list');
                themesList.innerHTML = '';

                for (const themeName in availableThemes) {
                    const theme = availableThemes[themeName];
                    const intervalMinutes = (theme.interval || 3600) / 60;
                    const isAllImages = themeName === 'All Images';

                    const badge = document.createElement('div');
                    badge.className = 'theme-badge';
                    // Only show theme as active if no atmosphere is active
                    if (themeName === activeTheme && !activeAtmosphere) {
                        badge.classList.add('active');
                    }

                    // Build HTML with conditional delete button
                    badge.innerHTML = `
                        <span class="theme-name" data-theme="${themeName}">${themeName}</span>
                        <div style="display: flex; align-items: center; gap: 5px; margin-top: 5px;">
                            <button class="interval-display-btn" data-theme="${themeName}" style="padding: 6px 12px; font-size: 12px; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                                ${intervalMinutes} min
                            </button>
                            <input type="number" class="interval-input" data-theme="${themeName}" value="${intervalMinutes}" min="1" max="1440" step="0.5" style="width: 80px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; display: none;">
                            ${!isAllImages ? `<button onclick="deleteTheme('${themeName}')" style="padding: 6px 12px; font-size: 12px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>` : ''}
                        </div>
                    `;

                    // Add click handler for theme name to activate theme
                    const themeNameSpan = badge.querySelector('.theme-name');
                    themeNameSpan.addEventListener('click', () => {
                        setActiveThemeByName(themeName);
                    });

                    // Add click handler for interval button
                    const intervalBtn = badge.querySelector('.interval-display-btn');
                    const intervalInput = badge.querySelector('.interval-input');

                    intervalBtn.addEventListener('click', () => {
                        intervalBtn.style.display = 'none';
                        intervalInput.style.display = 'block';
                        intervalInput.focus();
                        intervalInput.select();
                    });

                    // Save on blur or enter key
                    intervalInput.addEventListener('blur', () => {
                        saveThemeIntervalFromInput(themeName, intervalInput, intervalBtn);
                    });

                    intervalInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            intervalInput.blur();
                        }
                    });

                    themesList.appendChild(badge);
                }
            } catch (error) {
                console.error('Error loading themes:', error);
            }
        }

        async function createTheme() {
            const nameInput = document.getElementById('new-theme-name');
            const createBtn = document.getElementById('show-create-theme-btn');
            const name = nameInput.value.trim();

            if (!name) {
                showMessage('Please enter a theme name', 'error');
                return;
            }

            try {
                const response = await fetch('/api/themes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                if (response.ok) {
                    nameInput.value = '';
                    nameInput.style.display = 'none';
                    createBtn.style.display = 'block';
                    await loadThemes();
                    await loadImages(); // Reload to show theme selectors
                    showMessage(`Theme "${name}" created`, 'success');
                } else {
                    const error = await response.json();
                    showMessage(error.error || 'Error creating theme', 'error');
                }
            } catch (error) {
                console.error('Error creating theme:', error);
                showMessage('Error creating theme', 'error');
            }
        }

        function hideCreateThemeInput() {
            const nameInput = document.getElementById('new-theme-name');
            const createBtn = document.getElementById('show-create-theme-btn');
            nameInput.value = '';
            nameInput.style.display = 'none';
            createBtn.style.display = 'block';
        }

        async function saveThemeInterval(themeName) {
            const inputElement = document.getElementById(`interval-${themeName}`);
            const intervalMinutes = parseFloat(inputElement.value);

            if (!intervalMinutes || intervalMinutes < 1) {
                showMessage('Invalid interval value', 'error');
                return;
            }

            const intervalSeconds = Math.round(intervalMinutes * 60);

            try {
                const response = await fetch(`/api/themes/${encodeURIComponent(themeName)}/interval`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval: intervalSeconds })
                });

                if (response.ok) {
                    availableThemes[themeName].interval = intervalSeconds;
                    showMessage(`Interval updated for theme "${themeName}"`, 'success');
                } else {
                    showMessage('Error updating theme interval', 'error');
                }
            } catch (error) {
                console.error('Error updating theme interval:', error);
                showMessage('Error updating theme interval', 'error');
            }
        }

        async function saveThemeIntervalFromInput(themeName, inputElement, buttonElement) {
            const intervalMinutes = parseFloat(inputElement.value);

            if (!intervalMinutes || intervalMinutes < 1) {
                showMessage('Invalid interval value', 'error');
                inputElement.value = (availableThemes[themeName].interval || 3600) / 60;
                inputElement.style.display = 'none';
                buttonElement.style.display = 'block';
                return;
            }

            const intervalSeconds = Math.round(intervalMinutes * 60);

            try {
                const response = await fetch(`/api/themes/${encodeURIComponent(themeName)}/interval`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval: intervalSeconds })
                });

                if (response.ok) {
                    availableThemes[themeName].interval = intervalSeconds;
                    buttonElement.textContent = `${intervalMinutes} min`;
                    showMessage(`Interval updated for theme "${themeName}"`, 'success');
                } else {
                    showMessage('Error updating theme interval', 'error');
                    inputElement.value = (availableThemes[themeName].interval || 3600) / 60;
                }
            } catch (error) {
                console.error('Error updating theme interval:', error);
                showMessage('Error updating theme interval', 'error');
                inputElement.value = (availableThemes[themeName].interval || 3600) / 60;
            }

            // Switch back to button display
            inputElement.style.display = 'none';
            buttonElement.style.display = 'block';
        }

        async function deleteTheme(themeName) {
            if (!confirm(`Delete theme "${themeName}"? This will remove it from all images.`)) {
                return;
            }

            try {
                const response = await fetch(`/api/themes/${encodeURIComponent(themeName)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    await loadThemes();
                    await loadImages(); // Reload to update image cards
                    showMessage(`Theme "${themeName}" deleted`, 'success');
                } else {
                    showMessage('Error deleting theme', 'error');
                }
            } catch (error) {
                console.error('Error deleting theme:', error);
                showMessage('Error deleting theme', 'error');
            }
        }

        async function setActiveThemeByName(themeName) {
            if (!themeName) {
                showMessage('Please select a theme', 'error');
                return;
            }

            try {
                const response = await fetch('/api/themes/active', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ theme_name: themeName })
                });

                if (response.ok) {
                    activeTheme = themeName;
                    activeAtmosphere = null; // Backend clears this automatically

                    // Reload atmospheres and themes to update active state
                    await loadAtmospheres();
                    await loadThemes();

                    // Reload images to show filtered view
                    await loadImages();
                } else {
                    showMessage('Error setting active theme', 'error');
                }
            } catch (error) {
                console.error('Error setting active theme:', error);
                showMessage('Error setting active theme', 'error');
            }
        }

        async function updateImageThemes(imageName, themes) {
            try {
                const response = await fetch(`/api/images/${encodeURIComponent(imageName)}/themes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ themes })
                });

                if (!response.ok) {
                    showMessage('Error updating image themes', 'error');
                }
            } catch (error) {
                console.error('Error updating image themes:', error);
                showMessage('Error updating image themes', 'error');
            }
        }

        // Crop functionality
        let currentCropper = null;
        let currentCropImage = null;

        async function openCropModal(imageName, imageUrl) {
            currentCropImage = imageName;
            const modal = document.getElementById('crop-modal');
            const image = document.getElementById('crop-image');

            // Set image source
            image.src = imageUrl;

            // Show modal
            modal.classList.add('active');

            // Wait for image to load
            await new Promise(resolve => {
                if (image.complete) {
                    resolve();
                } else {
                    image.onload = resolve;
                }
            });

            // Destroy existing cropper if any
            if (currentCropper) {
                currentCropper.destroy();
            }

            // Get existing crop data if any
            const settings = await fetch('/api/settings').then(r => r.json());
            const imageCrops = settings.image_crops || {};
            const cropData = imageCrops[imageName];

            // Initialize cropper
            currentCropper = new Cropper(image, {
                viewMode: 1,
                dragMode: 'move',
                aspectRatio: NaN, // Free aspect ratio
                autoCropArea: 1,
                restore: false,
                guides: true,
                center: true,
                highlight: true,
                cropBoxMovable: true,
                cropBoxResizable: true,
                toggleDragModeOnDblclick: false,
                ready: function() {
                    // If crop data exists, set it
                    if (cropData) {
                        currentCropper.setData({
                            x: cropData.x,
                            y: cropData.y,
                            width: cropData.width,
                            height: cropData.height
                        });
                    }
                }
            });
        }

        function closeCropModal() {
            const modal = document.getElementById('crop-modal');
            modal.classList.remove('active');

            if (currentCropper) {
                currentCropper.destroy();
                currentCropper = null;
            }

            currentCropImage = null;
        }

        async function saveCrop() {
            if (!currentCropper || !currentCropImage) {
                return;
            }

            // Get crop data
            const cropData = currentCropper.getData();
            const imageData = currentCropper.getImageData();

            // Save crop data (as percentages for responsiveness)
            const cropInfo = {
                x: cropData.x,
                y: cropData.y,
                width: cropData.width,
                height: cropData.height,
                imageWidth: imageData.naturalWidth,
                imageHeight: imageData.naturalHeight
            };

            try {
                // Get current settings
                const settings = await fetch('/api/settings').then(r => r.json());

                // Update image_crops
                if (!settings.image_crops) {
                    settings.image_crops = {};
                }
                settings.image_crops[currentCropImage] = cropInfo;

                // Save settings
                const response = await fetch('/api/settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(settings)
                });

                if (response.ok) {
                    showMessage('Crop saved successfully!', 'success');
                    closeCropModal();
                } else {
                    showMessage('Failed to save crop', 'error');
                }
            } catch (error) {
                console.error('Error saving crop:', error);
                showMessage('Error saving crop', 'error');
            }
        }

        async function clearCrop() {
            if (!currentCropImage) {
                return;
            }

            try {
                // Get current settings
                const settings = await fetch('/api/settings').then(r => r.json());

                // Remove crop data
                if (settings.image_crops && settings.image_crops[currentCropImage]) {
                    delete settings.image_crops[currentCropImage];

                    // Save settings
                    const response = await fetch('/api/settings', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(settings)
                    });

                    if (response.ok) {
                        showMessage('Crop cleared successfully!', 'success');
                        closeCropModal();
                    } else {
                        showMessage('Failed to clear crop', 'error');
                    }
                }
            } catch (error) {
                console.error('Error clearing crop:', error);
                showMessage('Error clearing crop', 'error');
            }
        }

        // Handle "View Kiosk Display" link to sync with current image
        const viewKioskLink = document.getElementById('view-kiosk-link');

        if (viewKioskLink) {
            viewKioskLink.addEventListener('click', function(e) {
                e.preventDefault();

                // Fetch the current image being displayed on the kiosk
                fetch('/api/kiosk/current-image')
                    .then(response => response.json())
                    .then(data => {
                        // Build URL with current image parameter if available
                        let url = '/view';
                        if (data.image_name) {
                            url += '?image=' + encodeURIComponent(data.image_name);
                        }
                        // Navigate to the kiosk view (not blocked by pop-up blockers)
                        window.location.href = url;
                    })
                    .catch(error => {
                        console.error('Error fetching current image:', error);
                        // Fallback: just navigate to /view without parameter
                        window.location.href = '/view';
                    });
            });
        }

        // Handle "Create Atmosphere" button and input
        const showCreateAtmosphereBtn = document.getElementById('show-create-atmosphere-btn');
        const newAtmosphereNameInput = document.getElementById('new-atmosphere-name');

        if (showCreateAtmosphereBtn && newAtmosphereNameInput) {
            // Show input when button is clicked
            showCreateAtmosphereBtn.addEventListener('click', function() {
                showCreateAtmosphereBtn.style.display = 'none';
                newAtmosphereNameInput.style.display = 'block';
                newAtmosphereNameInput.focus();
            });

            // Create atmosphere on Enter key
            newAtmosphereNameInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    createAtmosphere();
                }
            });

            // Hide input on blur if empty
            newAtmosphereNameInput.addEventListener('blur', function() {
                if (!newAtmosphereNameInput.value.trim()) {
                    hideCreateAtmosphereInput();
                }
            });
        }

        // Handle "Create Theme" button and input
        const showCreateThemeBtn = document.getElementById('show-create-theme-btn');
        const newThemeNameInput = document.getElementById('new-theme-name');

        if (showCreateThemeBtn && newThemeNameInput) {
            // Show input when button is clicked
            showCreateThemeBtn.addEventListener('click', function() {
                showCreateThemeBtn.style.display = 'none';
                newThemeNameInput.style.display = 'block';
                newThemeNameInput.focus();
            });

            // Create theme on Enter key
            newThemeNameInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    createTheme();
                }
            });

            // Hide input on blur if empty
            newThemeNameInput.addEventListener('blur', function() {
                if (!newThemeNameInput.value.trim()) {
                    hideCreateThemeInput();
                }
            });
        }

        // Update LED indicators based on current kiosk image
        async function updateLEDs() {
            try {
                const response = await fetch('/api/kiosk/current-image');
                if (!response.ok) {
                    console.warn('Failed to fetch current image');
                    return;
                }
                const data = await response.json();
                const currentImage = data.current_image;

                // Update all LED indicators and image card borders
                const allLEDs = document.querySelectorAll('.current-image-led');
                allLEDs.forEach(led => {
                    const card = led.closest('.image-card');
                    if (led.dataset.imageName === currentImage) {
                        led.classList.add('active');
                        if (card) card.classList.add('active');
                    } else {
                        led.classList.remove('active');
                        if (card) card.classList.remove('active');
                    }
                });
            } catch (error) {
                console.error('Error updating LED indicators:', error);
            }
        }

        // Poll for current image every 1 second
        setInterval(updateLEDs, 1000);

        // Track shuffle_id to detect when kiosk reshuffles
        let previousShuffleId = null;

        // Check if shuffle_id has changed (kiosk reshuffled)
        async function checkShuffleIdChanged() {
            try {
                const response = await fetch('/api/settings');
                const settings = await response.json();
                const currentShuffleId = settings.shuffle_id;

                if (previousShuffleId !== null && previousShuffleId !== currentShuffleId) {
                    console.log(`Shuffle ID changed: ${previousShuffleId} -> ${currentShuffleId}. Reloading images...`);
                    await loadImages(); // Reload current images with new order
                }

                previousShuffleId = currentShuffleId;
            } catch (error) {
                console.error('Error checking shuffle_id:', error);
            }
        }

        // WebSocket event handlers for real-time updates
        socket.on('connect', () => {
            console.log('WebSocket connected');
        });

        socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });

        socket.on('reconnect', () => {
            console.log('WebSocket reconnected');
            // Reload page state after reconnection
            initializePage();
        });

        socket.on('debug_message', (msg) => {
            appendDebugMessage(msg);
        });

        socket.on('settings_update', (settings) => {
            console.log('Settings updated via WebSocket');
            // Check if shuffle_id changed
            if (previousShuffleId !== null && previousShuffleId !== settings.shuffle_id) {
                console.log(`Shuffle ID changed: ${previousShuffleId} -> ${settings.shuffle_id}. Reloading images...`);
                loadImages(); // Reload current images with new order
            }
            previousShuffleId = settings.shuffle_id;

            // Update themes and atmospheres in case they changed
            loadAtmospheres();
            loadThemes();
        });

        socket.on('image_list_changed', () => {
            console.log('Image list changed via WebSocket');
            loadImages();
        });

        // Load data on page load
        async function initializePage() {
            await loadAtmospheres();
            await loadThemes();
            await loadImages();
            updateLEDs(); // Initialize LED indicators after images are loaded

            // Initialize shuffle_id tracking
            const response = await fetch('/api/settings');
            const settings = await response.json();
            previousShuffleId = settings.shuffle_id;
        }

        initializePage();
    </script>

    <!-- Crop Modal -->
    <div id="crop-modal" class="crop-modal">
        <div class="crop-modal-content">
            <h2>Crop Image</h2>
            <div class="crop-container">
                <img id="crop-image" src="" alt="Image to crop">
            </div>
            <div class="crop-buttons">
                <button class="crop-button tertiary" onclick="closeCropModal()">Cancel</button>
                <button class="crop-button secondary" onclick="clearCrop()">Clear Crop</button>
                <button class="crop-button primary" onclick="saveCrop()">Save Crop</button>
            </div>
        </div>
    </div>

    <!-- Cropper.js Script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
</body>
</html>
