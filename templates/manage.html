<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiosk Image Management</title>

    <!-- Cropper.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            color: #444;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }

        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #fafafa;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #4CAF50;
            background: #f0f8f0;
        }

        .upload-area.dragging {
            border-color: #4CAF50;
            background: #e8f5e9;
        }

        #file-input {
            display: none;
        }

        .upload-button {
            background: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }

        .upload-button:hover {
            background: #45a049;
        }

        .settings-form {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .settings-form label {
            font-weight: 500;
            color: #555;
        }

        .settings-form input[type="number"] {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            width: 100px;
        }

        .settings-form input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .settings-form button {
            background: #2196F3;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .settings-form button:hover {
            background: #1976D2;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .image-card {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: visible;
            background: white;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
        }

        /* Keep image area clipped to rounded corners */
        .image-card > img,
        .image-card > div[style*="overflow: hidden"] {
            border-radius: 8px 8px 0 0;
            overflow: hidden;
        }

        .image-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .image-card.disabled {
            border: 1px solid #ccc;
        }

        .image-card.disabled img {
            filter: grayscale(100%);
            opacity: 0.5;
        }

        .image-card.disabled .card-info,
        .image-card.disabled .image-tags {
            opacity: 0.5;
        }

        .image-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            background: #f0f0f0;
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
        }

        .image-card img:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }

        /* Hover effect for crop containers */
        .image-card > div[style*="overflow: hidden"]:hover img {
            filter: brightness(1.1);
        }

        .image-checkbox-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 10;
        }

        .image-checkbox-container label {
            font-size: 12px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            margin: 0;
        }

        .image-checkbox-container input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .image-card-info {
            padding: 12px;
        }

        .image-card-name {
            font-size: 14px;
            color: #333;
            margin-bottom: 8px;
            word-break: break-all;
        }

        .image-card-size {
            font-size: 12px;
            color: #999;
            margin-bottom: 12px;
        }

        .delete-button {
            background: #f44336;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }

        .delete-button:hover {
            background: #d32f2f;
        }

        .message {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }

        .message.success {
            background: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #a5d6a7;
        }

        .message.error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ef9a9a;
        }

        .message.visible {
            display: block;
        }

        .links {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .links a {
            color: #2196F3;
            text-decoration: none;
            font-weight: 500;
        }

        .links a:hover {
            text-decoration: underline;
        }


        .remote-control {
            background: #fff3e0;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #ff9800;
            margin-bottom: 20px;
        }

        .remote-control h3 {
            color: #e65100;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .control-button {
            background: #ff9800;
            color: white;
            padding: 12px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .control-button:hover {
            background: #f57c00;
        }

        .control-button:active {
            transform: scale(0.95);
        }

        .control-button.danger {
            background: #f44336;
        }

        .control-button.danger:hover {
            background: #d32f2f;
        }

        .control-button.success {
            background: #4CAF50;
        }

        .control-button.success:hover {
            background: #45a049;
        }

        .control-button-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .led-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
            transition: background 0.3s;
        }

        .led-indicator.active {
            background: #2196F3;
            box-shadow: 0 0 8px #2196F3;
        }

        .debug-toggle-button {
            background: #9e9e9e;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.3s;
        }

        .debug-toggle-button:hover {
            background: #757575;
        }

        .debug-toggle-button.active {
            background: #4CAF50;
        }

        .debug-toggle-button.active:hover {
            background: #45a049;
        }

        .debug-panel {
            background: #f5f5f5;
            border: 2px solid #9e9e9e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .debug-panel h3 {
            color: #424242;
            margin-bottom: 15px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .debug-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .debug-toggle label {
            font-size: 14px;
            font-weight: 500;
        }

        .debug-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .debug-console {
            background: #263238;
            color: #aed581;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 15px;
            border-radius: 4px;
            height: 1000px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .debug-console-line {
            margin-bottom: 4px;
            word-wrap: break-word;
        }

        .debug-console-line.error {
            color: #ef5350;
        }

        .debug-console-line.info {
            color: #81c784;
        }

        .debug-timestamp {
            color: #78909c;
            margin-right: 8px;
        }

        .debug-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .debug-button {
            background: #757575;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .debug-button:hover {
            background: #616161;
        }

        .debug-panel.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .theme-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #e3f2fd;
            border: 1px solid #2196F3;
            border-radius: 4px;
            font-size: 14px;
            color: #1565c0;
        }

        .theme-badge button {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 12px;
        }

        .theme-badge button:hover {
            background: #d32f2f;
        }

        .image-themes {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .image-theme-tag {
            display: inline-block;
            padding: 3px 8px;
            background: #e3f2fd;
            color: #1565c0;
            border-radius: 3px;
            font-size: 11px;
        }

        .theme-selector {
            margin-top: 8px;
        }

        .theme-selector select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
            width: 100%;
        }

        /* Crop Modal */
        .crop-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .crop-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .crop-modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .crop-container {
            max-width: 800px;
            max-height: 600px;
            margin: 20px 0;
        }

        .crop-container img {
            max-width: 100%;
        }

        .crop-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 15px;
        }

        .crop-button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .crop-button.primary {
            background: #4CAF50;
            color: white;
        }

        .crop-button.primary:hover {
            background: #45a049;
        }

        .crop-button.secondary {
            background: #f44336;
            color: white;
        }

        .crop-button.secondary:hover {
            background: #da190b;
        }

        .crop-button.tertiary {
            background: #757575;
            color: white;
        }

        .crop-button.tertiary:hover {
            background: #616161;
        }

        .crop-image-button {
            background: #2196F3;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 8px;
        }

        /* Action menu styles */
        .action-menu-container {
            position: relative;
            margin-top: 8px;
        }

        .action-menu-button {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 12px;
            font-size: 20px;
            line-height: 1;
            cursor: pointer;
            width: 100%;
            transition: background 0.2s;
        }

        .action-menu-button:hover {
            background: #e0e0e0;
        }

        .action-menu-dropdown {
            position: absolute;
            bottom: 100%;
            right: 0;
            margin-bottom: 4px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            min-width: 180px;
            z-index: 1000;
            display: none;
        }

        .action-menu-dropdown.show {
            display: block;
        }

        .menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
            transition: background 0.2s;
            position: relative;
        }

        .menu-item:hover {
            background: #f5f5f5;
        }

        .menu-item:first-child {
            border-radius: 4px 4px 0 0;
        }

        .menu-item:last-child {
            border-radius: 0 0 4px 4px;
        }

        .menu-item-danger {
            color: #f44336;
        }

        .menu-item-danger:hover {
            background: #ffebee;
        }

        .menu-item.has-submenu {
            padding-right: 32px;
        }

        .submenu-arrow {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #999;
        }

        .submenu {
            position: absolute;
            left: 100%;
            bottom: 0;
            margin-left: 4px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            min-width: 150px;
            display: none;
            z-index: 1001;
        }

        .submenu.show {
            display: block;
        }

        .submenu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            color: #333;
            transition: background 0.2s;
        }

        .submenu-item:hover {
            background: #f5f5f5;
        }

        .submenu-item:first-child {
            border-radius: 4px 4px 0 0;
        }

        .submenu-item:last-child {
            border-radius: 0 0 4px 4px;
        }

        .crop-image-button:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Kiosk Image Management</h1>
        <p class="subtitle">Upload and manage images for your kiosk display</p>

        <div class="links">
            <a href="/view" id="view-kiosk-link">View Kiosk Display</a>
        </div>

        <div id="message" class="message"></div>

        <div class="remote-control">
            <h3>üéÆ Remote Control - Control the Kiosk Display</h3>
            <div class="control-buttons">
                <div class="control-button-wrapper">
                    <button class="control-button success" onclick="sendCommand('play')">‚ñ∂Ô∏è Play</button>
                    <div class="led-indicator" id="led-play"></div>
                </div>
                <div class="control-button-wrapper">
                    <button class="control-button danger" onclick="sendCommand('pause')">‚è∏Ô∏è Pause</button>
                    <div class="led-indicator" id="led-pause"></div>
                </div>
                <div class="control-button-wrapper">
                    <button class="control-button" onclick="sendCommand('reload')">üîÉ Reload</button>
                    <div class="led-indicator" id="led-reload"></div>
                </div>
                <div class="control-button-wrapper">
                    <button class="control-button" onclick="sendCommand('prev')">‚¨ÖÔ∏è Previous</button>
                    <div class="led-indicator" id="led-prev"></div>
                </div>
                <div class="control-button-wrapper">
                    <button class="control-button" onclick="sendCommand('next')">‚û°Ô∏è Next</button>
                    <div class="led-indicator" id="led-next"></div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Themes</h2>
            <p style="color: #666; margin-bottom: 15px;">Organize your images into themes. Each theme has its own slideshow interval. The "All Images" theme shows all enabled images.</p>

            <div style="display: flex; gap: 10px; margin-bottom: 20px; align-items: center;">
                <input type="text" id="new-theme-name" placeholder="Theme name" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; flex: 1;">
                <button onclick="createTheme()" style="background: #4CAF50; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">Create Theme</button>
            </div>

            <div style="margin-bottom: 15px;">
                <strong>Active Theme:</strong>
                <select id="active-theme-select" onchange="setActiveTheme()" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; margin-left: 10px;">
                </select>
            </div>

            <div id="themes-list" style="display: flex; flex-wrap: wrap; gap: 10px;">
                <!-- Themes will be loaded here -->
            </div>
        </div>

        <div class="section">
            <h2>Upload Images</h2>
            <div class="upload-area" id="upload-area" onclick="document.getElementById('file-input').click()">
                <p style="font-size: 18px; color: #666; margin-bottom: 10px;">
                    Drag and drop images here or click to select
                </p>
                <p style="font-size: 14px; color: #999;">
                    Supported formats: PNG, JPG, JPEG, GIF, WebP, BMP
                </p>
                <input type="file" id="file-input" accept="image/*" multiple>
                <button class="upload-button" onclick="event.stopPropagation(); document.getElementById('file-input').click()">
                    Choose Files
                </button>
            </div>
        </div>

        <div class="section">
            <h2>Current Images</h2>
            <div class="image-grid" id="image-grid">
                <p style="color: #999;">Loading images...</p>
            </div>
        </div>

        <div style="margin-bottom: 20px;">
            <button class="debug-toggle-button" onclick="toggleDebugPanel()">üêõ DEBUG</button>
        </div>

        <div class="debug-panel" id="debug-panel" style="display: none;">
            <h3>
                üêõ Debug Console - Kiosk Display Logs
                <div class="debug-toggle">
                    <input type="checkbox" id="debug-enabled" onchange="toggleDebug()">
                    <label for="debug-enabled">Enable</label>
                </div>
            </h3>
            <div class="debug-console" id="debug-console">
                <div class="debug-console-line">Debug console disabled. Enable to see live logs from the kiosk display.</div>
            </div>
            <div class="debug-controls">
                <button class="debug-button" onclick="clearDebugConsole()">Clear Console</button>
                <button class="debug-button" onclick="refreshDebugConsole()">Refresh Now</button>
            </div>
        </div>
    </div>

    <script>
        // Menu handling functions (define early for use in createImageCard)
        function toggleMenu(menuContainer) {
            const dropdown = menuContainer.querySelector('.action-menu-dropdown');
            const isOpen = dropdown.classList.contains('show');

            // Close all other menus first
            closeAllMenus();

            // Toggle this menu
            if (!isOpen) {
                dropdown.classList.add('show');
                // Raise the parent card's z-index so dropdown and submenu appear above other cards
                const card = menuContainer.closest('.image-card');
                if (card) {
                    card.style.zIndex = '1002';
                }
            }
        }

        function closeAllMenus() {
            document.querySelectorAll('.action-menu-dropdown.show').forEach(dropdown => {
                dropdown.classList.remove('show');
                // Reset the parent card's z-index
                const card = dropdown.closest('.image-card');
                if (card) {
                    card.style.zIndex = '';
                }
            });
        }

        // Close menus when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.action-menu-container')) {
                closeAllMenus();
            }
        });

        // Debug console state
        let debugEnabled = false;
        let debugPollInterval = null;
        let debugPanelVisible = false;

        // Toggle debug panel visibility
        function toggleDebugPanel() {
            const panel = document.getElementById('debug-panel');
            const button = document.querySelector('.debug-toggle-button');
            debugPanelVisible = !debugPanelVisible;

            if (debugPanelVisible) {
                panel.style.display = 'block';
                button.classList.add('active');
            } else {
                panel.style.display = 'none';
                button.classList.remove('active');
            }
        }

        // Toggle debug console
        function toggleDebug() {
            debugEnabled = document.getElementById('debug-enabled').checked;

            if (debugEnabled) {
                // Start polling for debug messages
                refreshDebugConsole();
                debugPollInterval = setInterval(refreshDebugConsole, 1000); // Poll every second
                document.getElementById('debug-panel').classList.remove('disabled');
            } else {
                // Stop polling
                if (debugPollInterval) {
                    clearInterval(debugPollInterval);
                    debugPollInterval = null;
                }
                const console = document.getElementById('debug-console');
                console.innerHTML = '<div class="debug-console-line">Debug console disabled. Enable to see live logs from the kiosk display.</div>';
            }
        }

        // Refresh debug console with latest messages
        async function refreshDebugConsole() {
            if (!debugEnabled) return;

            try {
                const response = await fetch('/api/debug/messages');
                const messages = await response.json();

                const console = document.getElementById('debug-console');
                console.innerHTML = '';

                if (messages.length === 0) {
                    console.innerHTML = '<div class="debug-console-line">No debug messages yet. Waiting for kiosk activity...</div>';
                    return;
                }

                messages.forEach(msg => {
                    const line = document.createElement('div');
                    line.className = `debug-console-line ${msg.level}`;

                    const timestamp = new Date(msg.timestamp * 1000).toLocaleTimeString();
                    const timestampSpan = document.createElement('span');
                    timestampSpan.className = 'debug-timestamp';
                    timestampSpan.textContent = `[${timestamp}]`;

                    line.appendChild(timestampSpan);
                    line.appendChild(document.createTextNode(msg.message));

                    console.appendChild(line);
                });

                // Auto-scroll to bottom
                console.scrollTop = console.scrollHeight;
            } catch (error) {
                console.error('Error fetching debug messages:', error);
            }
        }

        // Clear debug console
        async function clearDebugConsole() {
            try {
                await fetch('/api/debug/clear', { method: 'POST' });
                const console = document.getElementById('debug-console');
                console.innerHTML = '<div class="debug-console-line">Console cleared.</div>';
            } catch (error) {
                console.error('Error clearing debug console:', error);
            }
        }

        // Track current playback state
        let isPlaying = true; // Assume playing by default

        // Update LED indicators
        function updateLEDs() {
            // Update play/pause LEDs
            if (isPlaying) {
                document.getElementById('led-play').classList.add('active');
                document.getElementById('led-pause').classList.remove('active');
            } else {
                document.getElementById('led-play').classList.remove('active');
                document.getElementById('led-pause').classList.add('active');
            }
        }

        // Flash LED briefly for action buttons
        function flashLED(ledId) {
            const led = document.getElementById(ledId);
            led.classList.add('active');
            setTimeout(() => {
                led.classList.remove('active');
            }, 500);
        }

        // Send remote control command
        async function sendCommand(command) {
            try {
                const response = await fetch('/api/control/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ command })
                });

                if (!response.ok) {
                    showMessage('Error sending command', 'error');
                    return;
                }

                // Update LED indicators based on command
                switch(command) {
                    case 'play':
                        isPlaying = true;
                        updateLEDs();
                        break;
                    case 'pause':
                        isPlaying = false;
                        updateLEDs();
                        break;
                    case 'prev':
                        flashLED('led-prev');
                        break;
                    case 'next':
                        flashLED('led-next');
                        break;
                    case 'reload':
                        isPlaying = true; // Reload resumes playback
                        updateLEDs();
                        flashLED('led-reload');
                        break;
                }
            } catch (error) {
                console.error('Error sending command:', error);
                showMessage('Error sending command', 'error');
            }
        }

        // Jump to specific image in kiosk display
        async function jumpToImage(imageName) {
            try {
                const response = await fetch('/api/control/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ command: 'jump', image_name: imageName })
                });

                if (!response.ok) {
                    showMessage('Error jumping to image', 'error');
                }
                // Success - no message shown
            } catch (error) {
                console.error('Error jumping to image:', error);
                showMessage('Error jumping to image', 'error');
            }
        }

        // Load and display images
        async function loadImages() {
            try {
                const response = await fetch('/api/images');
                const images = await response.json();

                // Load crop settings
                const settingsResponse = await fetch('/api/settings');
                const settings = await settingsResponse.json();
                const imageCrops = settings.image_crops || {};

                const grid = document.getElementById('image-grid');
                grid.innerHTML = '';

                if (images.length === 0) {
                    grid.innerHTML = '<p style="color: #999;">No images uploaded yet</p>';
                    return;
                }

                // Filter images by active theme
                // "All Images" is a special theme that shows all images without filtering
                let filteredImages = images;
                if (activeTheme && activeTheme !== 'All Images') {
                    filteredImages = images.filter(image => {
                        return image.themes && image.themes.includes(activeTheme);
                    });
                }

                if (filteredImages.length === 0 && activeTheme && activeTheme !== 'All Images') {
                    grid.innerHTML = '<p style="color: #999;">No images in the selected theme</p>';
                    return;
                }

                filteredImages.forEach(image => {
                    const cropData = imageCrops[image.name];
                    const card = createImageCard(image, cropData);
                    grid.appendChild(card);
                });
            } catch (error) {
                console.error('Error loading images:', error);
                showMessage('Error loading images', 'error');
            }
        }

        // Apply crop to thumbnail image
        function applyCropToThumbnail(img, container, cropData) {
            const containerW = container.clientWidth;
            const containerH = container.clientHeight; // 200px

            const cropX = cropData.x;
            const cropY = cropData.y;
            const cropW = cropData.width;
            const cropH = cropData.height;
            const imgW = cropData.imageWidth;
            const imgH = cropData.imageHeight;

            // Calculate scale to make crop region fill container (cover behavior)
            const scaleX = containerW / cropW;
            const scaleY = containerH / cropH;
            const scale = Math.max(scaleX, scaleY);

            // Calculate scaled image dimensions
            const scaledImgW = imgW * scale;
            const scaledImgH = imgH * scale;

            // Calculate scaled crop dimensions
            const scaledCropW = cropW * scale;
            const scaledCropH = cropH * scale;

            // Calculate position to place crop region
            const offsetX = -cropX * scale;
            const offsetY = -cropY * scale;

            // Center the crop region in container
            const centerX = (containerW - scaledCropW) / 2;
            const centerY = (containerH - scaledCropH) / 2;

            // Apply styles
            img.style.position = 'absolute';
            img.style.width = `${scaledImgW}px`;
            img.style.height = `${scaledImgH}px`;
            img.style.left = `${offsetX + centerX}px`;
            img.style.top = `${offsetY + centerY}px`;
            img.style.objectFit = 'fill';
            img.style.maxWidth = 'none';
            img.style.maxHeight = 'none';
        }

        // Create image card element
        function createImageCard(image, cropData) {
            const card = document.createElement('div');
            card.className = 'image-card';
            if (!image.enabled) {
                card.classList.add('disabled');
            }

            // If crop exists, create a container for the cropped image
            if (cropData) {
                const cropContainer = document.createElement('div');
                cropContainer.style.width = '100%';
                cropContainer.style.height = '200px';
                cropContainer.style.overflow = 'hidden';
                cropContainer.style.position = 'relative';
                cropContainer.style.background = '#f0f0f0';
                cropContainer.style.cursor = 'pointer';
                cropContainer.onclick = () => jumpToImage(image.name);
                cropContainer.title = 'Click to jump to this image in the kiosk display';

                const img = document.createElement('img');
                img.src = image.url;
                img.alt = image.name;
                img.style.cursor = 'pointer';

                // Apply crop when image loads
                img.onload = () => applyCropToThumbnail(img, cropContainer, cropData);

                cropContainer.appendChild(img);
                card.appendChild(cropContainer);
            } else {
                // No crop - show normal image
                const img = document.createElement('img');
                img.src = image.url;
                img.alt = image.name;
                img.style.cursor = 'pointer';
                img.onclick = () => jumpToImage(image.name);
                img.title = 'Click to jump to this image in the kiosk display';
                card.appendChild(img);
            }

            // Create checkbox container
            const checkboxContainer = document.createElement('div');
            checkboxContainer.className = 'image-checkbox-container';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = image.enabled;
            checkbox.id = `enable-${image.name}`;
            checkbox.onchange = () => toggleImageEnabled(image.name, checkbox.checked, card);

            const label = document.createElement('label');
            label.htmlFor = `enable-${image.name}`;
            label.textContent = 'Show';

            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(label);

            const info = document.createElement('div');
            info.className = 'image-card-info';

            // Theme tags
            const themesDiv = document.createElement('div');
            themesDiv.className = 'image-themes';
            (image.themes || []).forEach(themeName => {
                const tag = document.createElement('span');
                tag.className = 'image-theme-tag';
                tag.style.cursor = 'pointer';
                tag.title = 'Click to remove from theme';
                tag.textContent = themeName + ' ‚úï';
                tag.onclick = async () => {
                    const newThemes = (image.themes || []).filter(t => t !== themeName);
                    await updateImageThemes(image.name, newThemes);
                    await loadImages();
                };
                themesDiv.appendChild(tag);
            });

            // Action menu (three dots)
            const menuContainer = document.createElement('div');
            menuContainer.className = 'action-menu-container';

            const menuButton = document.createElement('button');
            menuButton.className = 'action-menu-button';
            menuButton.innerHTML = '‚ãÆ';
            menuButton.title = 'Actions';
            menuButton.onclick = (e) => {
                e.stopPropagation();
                toggleMenu(menuContainer);
            };

            const menuDropdown = document.createElement('div');
            menuDropdown.className = 'action-menu-dropdown';

            // Add to theme submenu
            if (Object.keys(availableThemes).length > 0) {
                const themeMenuItem = document.createElement('div');
                themeMenuItem.className = 'menu-item has-submenu';
                themeMenuItem.innerHTML = 'Add to theme <span class="submenu-arrow">‚ñ∏</span>';

                const themeSubmenu = document.createElement('div');
                themeSubmenu.className = 'submenu';

                for (const themeName in availableThemes) {
                    if (!(image.themes || []).includes(themeName)) {
                        const themeOption = document.createElement('div');
                        themeOption.className = 'submenu-item';
                        themeOption.textContent = themeName;
                        themeOption.onclick = async (e) => {
                            e.stopPropagation();
                            const newThemes = [...(image.themes || []), themeName];
                            await updateImageThemes(image.name, newThemes);
                            await loadImages();
                        };
                        themeSubmenu.appendChild(themeOption);
                    }
                }

                themeMenuItem.appendChild(themeSubmenu);

                // Handle submenu hover interaction
                themeMenuItem.addEventListener('mouseenter', () => {
                    themeSubmenu.classList.add('show');
                });

                themeMenuItem.addEventListener('mouseleave', (e) => {
                    // Delay hiding to allow mouse movement to submenu
                    setTimeout(() => {
                        if (!themeSubmenu.matches(':hover')) {
                            themeSubmenu.classList.remove('show');
                        }
                    }, 100);
                });

                themeSubmenu.addEventListener('mouseleave', () => {
                    themeSubmenu.classList.remove('show');
                });

                menuDropdown.appendChild(themeMenuItem);
            }

            // Crop menu item
            const cropMenuItem = document.createElement('div');
            cropMenuItem.className = 'menu-item';
            cropMenuItem.textContent = 'Crop';
            cropMenuItem.onclick = (e) => {
                e.stopPropagation();
                closeAllMenus();
                openCropModal(image.name, image.url);
            };
            menuDropdown.appendChild(cropMenuItem);

            // Delete menu item
            const deleteMenuItem = document.createElement('div');
            deleteMenuItem.className = 'menu-item menu-item-danger';
            deleteMenuItem.textContent = 'Delete';
            deleteMenuItem.onclick = (e) => {
                e.stopPropagation();
                closeAllMenus();
                deleteImage(image.name);
            };
            menuDropdown.appendChild(deleteMenuItem);

            menuContainer.appendChild(menuButton);
            menuContainer.appendChild(menuDropdown);

            info.appendChild(themesDiv);
            info.appendChild(menuContainer);

            card.appendChild(checkboxContainer);
            // Image or crop container already appended above
            card.appendChild(info);

            return card;
        }

        // Delete image
        async function deleteImage(filename) {
            if (!confirm(`Delete ${filename}?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/images/${encodeURIComponent(filename)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    showMessage('Image deleted successfully', 'success');
                    loadImages();
                } else {
                    showMessage('Error deleting image', 'error');
                }
            } catch (error) {
                console.error('Error deleting image:', error);
                showMessage('Error deleting image', 'error');
            }
        }

        // Toggle image enabled state
        async function toggleImageEnabled(filename, enabled, cardElement) {
            try {
                const response = await fetch(`/api/images/${encodeURIComponent(filename)}/toggle`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled })
                });

                if (response.ok) {
                    // Update visual state immediately
                    if (enabled) {
                        cardElement.classList.remove('disabled');
                    } else {
                        cardElement.classList.add('disabled');
                    }
                } else {
                    showMessage('Error updating image state', 'error');
                }
            } catch (error) {
                console.error('Error toggling image:', error);
                showMessage('Error updating image state', 'error');
            }
        }

        // Upload images
        async function uploadFiles(files) {
            for (const file of files) {
                const formData = new FormData();
                formData.append('file', file);

                try {
                    const response = await fetch('/api/images', {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        showMessage(`${file.name} uploaded successfully`, 'success');
                    } else {
                        const error = await response.json();
                        showMessage(`Error uploading ${file.name}: ${error.error}`, 'error');
                    }
                } catch (error) {
                    console.error('Error uploading file:', error);
                    showMessage(`Error uploading ${file.name}`, 'error');
                }
            }

            loadImages();
        }

        // Show message
        function showMessage(text, type) {
            const message = document.getElementById('message');
            message.textContent = text;
            message.className = `message ${type} visible`;

            setTimeout(() => {
                message.classList.remove('visible');
            }, 3000);
        }

        // File input change handler
        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                uploadFiles(files);
            }
            e.target.value = ''; // Reset input
        });

        // Drag and drop handlers
        const uploadArea = document.getElementById('upload-area');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragging');
        });

        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragging');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragging');

            const files = Array.from(e.dataTransfer.files).filter(file =>
                file.type.startsWith('image/')
            );

            if (files.length > 0) {
                uploadFiles(files);
            }
        });

        // Theme management functions
        let availableThemes = {};
        let activeTheme = null;

        async function loadThemes() {
            try {
                const response = await fetch('/api/themes');
                const data = await response.json();
                availableThemes = data.themes;
                activeTheme = data.active_theme;

                // Update themes list
                const themesList = document.getElementById('themes-list');
                themesList.innerHTML = '';

                for (const themeName in availableThemes) {
                    const theme = availableThemes[themeName];
                    const intervalMinutes = (theme.interval || 3600) / 60;
                    const isAllImages = themeName === 'All Images';

                    const badge = document.createElement('div');
                    badge.className = 'theme-badge';

                    // Build HTML with conditional delete button
                    badge.innerHTML = `
                        <span style="font-weight: 500;">${themeName}</span>
                        <div style="display: flex; align-items: center; gap: 5px; margin-top: 5px;">
                            <button class="interval-display-btn" data-theme="${themeName}" style="padding: 6px 12px; font-size: 12px; background: #f5f5f5; color: #333; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                                ${intervalMinutes} min
                            </button>
                            <input type="number" class="interval-input" data-theme="${themeName}" value="${intervalMinutes}" min="1" max="1440" step="0.5" style="width: 80px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; display: none;">
                            ${!isAllImages ? `<button onclick="deleteTheme('${themeName}')" style="padding: 6px 12px; font-size: 12px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Delete</button>` : ''}
                        </div>
                    `;

                    // Add click handler for interval button
                    const intervalBtn = badge.querySelector('.interval-display-btn');
                    const intervalInput = badge.querySelector('.interval-input');

                    intervalBtn.addEventListener('click', () => {
                        intervalBtn.style.display = 'none';
                        intervalInput.style.display = 'block';
                        intervalInput.focus();
                        intervalInput.select();
                    });

                    // Save on blur or enter key
                    intervalInput.addEventListener('blur', () => {
                        saveThemeIntervalFromInput(themeName, intervalInput, intervalBtn);
                    });

                    intervalInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            intervalInput.blur();
                        }
                    });

                    themesList.appendChild(badge);
                }

                // Update active theme dropdown
                const select = document.getElementById('active-theme-select');
                select.innerHTML = '';
                for (const themeName in availableThemes) {
                    const option = document.createElement('option');
                    option.value = themeName;
                    option.textContent = themeName;
                    if (themeName === activeTheme) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                }
            } catch (error) {
                console.error('Error loading themes:', error);
            }
        }

        async function createTheme() {
            const nameInput = document.getElementById('new-theme-name');
            const name = nameInput.value.trim();

            if (!name) {
                showMessage('Please enter a theme name', 'error');
                return;
            }

            try {
                const response = await fetch('/api/themes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                if (response.ok) {
                    nameInput.value = '';
                    await loadThemes();
                    await loadImages(); // Reload to show theme selectors
                    showMessage(`Theme "${name}" created`, 'success');
                } else {
                    const error = await response.json();
                    showMessage(error.error || 'Error creating theme', 'error');
                }
            } catch (error) {
                console.error('Error creating theme:', error);
                showMessage('Error creating theme', 'error');
            }
        }

        async function saveThemeInterval(themeName) {
            const inputElement = document.getElementById(`interval-${themeName}`);
            const intervalMinutes = parseFloat(inputElement.value);

            if (!intervalMinutes || intervalMinutes < 1) {
                showMessage('Invalid interval value', 'error');
                return;
            }

            const intervalSeconds = Math.round(intervalMinutes * 60);

            try {
                const response = await fetch(`/api/themes/${encodeURIComponent(themeName)}/interval`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval: intervalSeconds })
                });

                if (response.ok) {
                    availableThemes[themeName].interval = intervalSeconds;
                    showMessage(`Interval updated for theme "${themeName}"`, 'success');
                } else {
                    showMessage('Error updating theme interval', 'error');
                }
            } catch (error) {
                console.error('Error updating theme interval:', error);
                showMessage('Error updating theme interval', 'error');
            }
        }

        async function saveThemeIntervalFromInput(themeName, inputElement, buttonElement) {
            const intervalMinutes = parseFloat(inputElement.value);

            if (!intervalMinutes || intervalMinutes < 1) {
                showMessage('Invalid interval value', 'error');
                inputElement.value = (availableThemes[themeName].interval || 3600) / 60;
                inputElement.style.display = 'none';
                buttonElement.style.display = 'block';
                return;
            }

            const intervalSeconds = Math.round(intervalMinutes * 60);

            try {
                const response = await fetch(`/api/themes/${encodeURIComponent(themeName)}/interval`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval: intervalSeconds })
                });

                if (response.ok) {
                    availableThemes[themeName].interval = intervalSeconds;
                    buttonElement.textContent = `${intervalMinutes} min`;
                    showMessage(`Interval updated for theme "${themeName}"`, 'success');
                } else {
                    showMessage('Error updating theme interval', 'error');
                    inputElement.value = (availableThemes[themeName].interval || 3600) / 60;
                }
            } catch (error) {
                console.error('Error updating theme interval:', error);
                showMessage('Error updating theme interval', 'error');
                inputElement.value = (availableThemes[themeName].interval || 3600) / 60;
            }

            // Switch back to button display
            inputElement.style.display = 'none';
            buttonElement.style.display = 'block';
        }

        async function deleteTheme(themeName) {
            if (!confirm(`Delete theme "${themeName}"? This will remove it from all images.`)) {
                return;
            }

            try {
                const response = await fetch(`/api/themes/${encodeURIComponent(themeName)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    await loadThemes();
                    await loadImages(); // Reload to update image cards
                    showMessage(`Theme "${themeName}" deleted`, 'success');
                } else {
                    showMessage('Error deleting theme', 'error');
                }
            } catch (error) {
                console.error('Error deleting theme:', error);
                showMessage('Error deleting theme', 'error');
            }
        }

        async function setActiveTheme() {
            const select = document.getElementById('active-theme-select');
            const themeName = select.value;

            if (!themeName) {
                showMessage('Please select a theme', 'error');
                return;
            }

            try {
                const response = await fetch('/api/themes/active', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ theme_name: themeName })
                });

                if (response.ok) {
                    activeTheme = themeName;

                    // Reload images to show filtered view
                    await loadImages();
                } else {
                    showMessage('Error setting active theme', 'error');
                }
            } catch (error) {
                console.error('Error setting active theme:', error);
                showMessage('Error setting active theme', 'error');
            }
        }

        async function updateImageThemes(imageName, themes) {
            try {
                const response = await fetch(`/api/images/${encodeURIComponent(imageName)}/themes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ themes })
                });

                if (!response.ok) {
                    showMessage('Error updating image themes', 'error');
                }
            } catch (error) {
                console.error('Error updating image themes:', error);
                showMessage('Error updating image themes', 'error');
            }
        }

        // Crop functionality
        let currentCropper = null;
        let currentCropImage = null;

        async function openCropModal(imageName, imageUrl) {
            currentCropImage = imageName;
            const modal = document.getElementById('crop-modal');
            const image = document.getElementById('crop-image');

            // Set image source
            image.src = imageUrl;

            // Show modal
            modal.classList.add('active');

            // Wait for image to load
            await new Promise(resolve => {
                if (image.complete) {
                    resolve();
                } else {
                    image.onload = resolve;
                }
            });

            // Destroy existing cropper if any
            if (currentCropper) {
                currentCropper.destroy();
            }

            // Get existing crop data if any
            const settings = await fetch('/api/settings').then(r => r.json());
            const imageCrops = settings.image_crops || {};
            const cropData = imageCrops[imageName];

            // Initialize cropper
            currentCropper = new Cropper(image, {
                viewMode: 1,
                dragMode: 'move',
                aspectRatio: NaN, // Free aspect ratio
                autoCropArea: 1,
                restore: false,
                guides: true,
                center: true,
                highlight: true,
                cropBoxMovable: true,
                cropBoxResizable: true,
                toggleDragModeOnDblclick: false,
                ready: function() {
                    // If crop data exists, set it
                    if (cropData) {
                        currentCropper.setData({
                            x: cropData.x,
                            y: cropData.y,
                            width: cropData.width,
                            height: cropData.height
                        });
                    }
                }
            });
        }

        function closeCropModal() {
            const modal = document.getElementById('crop-modal');
            modal.classList.remove('active');

            if (currentCropper) {
                currentCropper.destroy();
                currentCropper = null;
            }

            currentCropImage = null;
        }

        async function saveCrop() {
            if (!currentCropper || !currentCropImage) {
                return;
            }

            // Get crop data
            const cropData = currentCropper.getData();
            const imageData = currentCropper.getImageData();

            // Save crop data (as percentages for responsiveness)
            const cropInfo = {
                x: cropData.x,
                y: cropData.y,
                width: cropData.width,
                height: cropData.height,
                imageWidth: imageData.naturalWidth,
                imageHeight: imageData.naturalHeight
            };

            try {
                // Get current settings
                const settings = await fetch('/api/settings').then(r => r.json());

                // Update image_crops
                if (!settings.image_crops) {
                    settings.image_crops = {};
                }
                settings.image_crops[currentCropImage] = cropInfo;

                // Save settings
                const response = await fetch('/api/settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(settings)
                });

                if (response.ok) {
                    showMessage('Crop saved successfully!', 'success');
                    closeCropModal();
                } else {
                    showMessage('Failed to save crop', 'error');
                }
            } catch (error) {
                console.error('Error saving crop:', error);
                showMessage('Error saving crop', 'error');
            }
        }

        async function clearCrop() {
            if (!currentCropImage) {
                return;
            }

            try {
                // Get current settings
                const settings = await fetch('/api/settings').then(r => r.json());

                // Remove crop data
                if (settings.image_crops && settings.image_crops[currentCropImage]) {
                    delete settings.image_crops[currentCropImage];

                    // Save settings
                    const response = await fetch('/api/settings', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(settings)
                    });

                    if (response.ok) {
                        showMessage('Crop cleared successfully!', 'success');
                        closeCropModal();
                    } else {
                        showMessage('Failed to clear crop', 'error');
                    }
                }
            } catch (error) {
                console.error('Error clearing crop:', error);
                showMessage('Error clearing crop', 'error');
            }
        }

        // Handle "View Kiosk Display" link to sync with current image
        const viewKioskLink = document.getElementById('view-kiosk-link');

        if (viewKioskLink) {
            viewKioskLink.addEventListener('click', function(e) {
                e.preventDefault();

                // Fetch the current image being displayed on the kiosk
                fetch('/api/kiosk/current-image')
                    .then(response => response.json())
                    .then(data => {
                        // Build URL with current image parameter if available
                        let url = '/view';
                        if (data.image_name) {
                            url += '?image=' + encodeURIComponent(data.image_name);
                        }
                        // Navigate to the kiosk view (not blocked by pop-up blockers)
                        window.location.href = url;
                    })
                    .catch(error => {
                        console.error('Error fetching current image:', error);
                        // Fallback: just navigate to /view without parameter
                        window.location.href = '/view';
                    });
            });
        }

        // Load data on page load
        loadThemes();
        loadImages();
        updateLEDs(); // Initialize LED indicators
    </script>

    <!-- Crop Modal -->
    <div id="crop-modal" class="crop-modal">
        <div class="crop-modal-content">
            <h2>Crop Image</h2>
            <div class="crop-container">
                <img id="crop-image" src="" alt="Image to crop">
            </div>
            <div class="crop-buttons">
                <button class="crop-button tertiary" onclick="closeCropModal()">Cancel</button>
                <button class="crop-button secondary" onclick="clearCrop()">Clear Crop</button>
                <button class="crop-button primary" onclick="saveCrop()">Save Crop</button>
            </div>
        </div>
    </div>

    <!-- Cropper.js Script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
</body>
</html>
